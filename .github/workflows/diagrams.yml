name: Draw.io to PNG Processing V3

on:
  push:
    paths:
      - 'drawio_files/**/*.drawio'
      - 'drawio_files/**'  # Also trigger on folder changes
  workflow_dispatch:

env:
  DRAWIO_VERSION: "26.2.2"

permissions:
  contents: write

jobs:
  process:
    runs-on: ubuntu-latest
    outputs:
      processed: ${{ steps.convert.outputs.processed }}
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Draw.io
        continue-on-error: true
        run: |
          set -e
          sudo apt-get update
          # Install dependencies for AppImage + headless Electron
          sudo apt-get install -y wget xvfb jq xdg-utils fonts-liberation libcurl4 \
            libgtk-3-0 libnss3 libnspr4 libxss1 libxtst6 libxrandr2 libasound2 libgbm1 libnotify4 \
            libx11-xcb1 libxcomposite1 libxdamage1 libxshmfence1 libatk-bridge2.0-0 libatspi2.0-0 libdrm2 libpangocairo-1.0-0 libpango-1.0-0 \
            libayatana-appindicator1 || true
          # AppImage requires FUSE 2 on Ubuntu; try both package names depending on runner image
          sudo apt-get install -y libfuse2 || sudo apt-get install -y libfuse2t64
          # Download draw.io AppImage to a fixed location
          APPIMAGE="drawio-x86_64-${{ env.DRAWIO_VERSION }}.AppImage"
          sudo mkdir -p /opt/drawio
          sudo wget -q -O "/opt/drawio/${APPIMAGE}" "https://github.com/jgraph/drawio-desktop/releases/download/v${{ env.DRAWIO_VERSION }}/${APPIMAGE}"
          sudo chmod +x "/opt/drawio/${APPIMAGE}"
          # Provide a drawio wrapper so existing commands keep working (avoid FUSE via extract-and-run)
          sudo tee /usr/local/bin/drawio >/dev/null <<'EOS'
          #!/usr/bin/env bash
          set -e
          export APPIMAGE_EXTRACT_AND_RUN=1
          APP="/opt/drawio/drawio-x86_64-${DRAWIO_VERSION}.AppImage"
          exec "$APP" "$@"
          EOS
          sudo chmod +x /usr/local/bin/drawio
          # Sanity check
          xvfb-run --auto-servernum --server-args="-screen 0 1024x768x24" drawio --version || true

      - name: Auto-assign IDs to new diagrams
        id: assign_ids
        run: |
          echo "üÜî Checking for diagrams without ID prefixes..."
          
          # Create diagram-registry.json if it doesn't exist
          if [[ ! -f "diagram-registry.json" ]]; then
            echo "üìù Creating initial diagram registry..."
            current_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            cat > diagram-registry.json << EOF
          {
            "nextId": 1,
            "version": "1.0", 
            "created": "$current_time",
            "lastUpdated": "$current_time",
            "mappings": {}
          }
          EOF
          fi
          
          # Check for files without ID prefixes
          unprocessed_count=0
          if [[ -d "drawio_files" ]]; then
            while IFS= read -r -d '' file; do
              basename_file=$(basename "$file")
              if [[ ! "$basename_file" =~ ^[0-9]{3}_ ]]; then
                ((unprocessed_count++))
              fi
            done < <(find drawio_files -name "*.drawio" -type f -print0 2>/dev/null || true)
          fi
          
          echo "üìä Found $unprocessed_count files without ID prefixes"
          
          if [[ $unprocessed_count -gt 0 ]]; then
            echo "üöÄ Starting automatic ID assignment..."
            
            # Get next ID from registry
            next_id=$(jq -r '.nextId' diagram-registry.json)
            current_id=$next_id
            
            echo "üÜî Starting from ID: $(printf "%03d" $current_id)"
            
            # Process each file without ID
            while IFS= read -r -d '' file; do
              basename_file=$(basename "$file")
              
              # Skip files that already have IDs
              if [[ "$basename_file" =~ ^[0-9]{3}_ ]]; then
                continue
              fi
              
              id_padded=$(printf "%03d" $current_id)
              new_file="${id_padded}_${basename_file}"
              
              echo "üîÑ Assigning ID $id_padded to: $basename_file"
              
              # Rename drawio file
              mv "drawio_files/$basename_file" "drawio_files/$new_file"
              echo "‚úÖ Renamed: $basename_file ‚Üí $new_file"
              
              # Rename PNG file if it exists
              png_file="${basename_file%.drawio}.png"
              new_png_file="${id_padded}_${png_file}"
              
              if [[ -f "png_files/$png_file" ]]; then
                mv "png_files/$png_file" "png_files/$new_png_file"
                echo "‚úÖ Renamed PNG: $png_file ‚Üí $new_png_file"
              fi
              
              # Extract metadata for registry
              title=$(echo "$basename_file" | sed 's/\.drawio$//' | sed 's/^[0-9]\.[0-9]\.*//')
              topic=$(echo "$basename_file" | sed 's/\..*$//')
              level=$(echo "$basename_file" | sed 's/^[0-9]\.\([0-9]\)\..*$/\1/')
              current_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
              
              # Add mapping to registry
              temp_registry=$(mktemp)
              jq --arg id "$id_padded" \
                 --arg orig_name "$basename_file" \
                 --arg drawio_file "$new_file" \
                 --arg png_file "$new_png_file" \
                 --arg title "$title" \
                 --arg topic "$topic" \
                 --arg level "$level" \
                 --arg current_time "$current_time" \
                 '.mappings[$id] = {
                   "id": $id,
                   "originalName": $orig_name,
                   "currentDrawioFile": $drawio_file,
                   "currentPngFile": $png_file,
                   "title": $title,
                   "topic": ($topic | tonumber),
                   "level": ($level | tonumber),
                   "created": $current_time,
                   "lastModified": $current_time,
                   "status": "active"
                 }' diagram-registry.json > "$temp_registry"
              
              mv "$temp_registry" diagram-registry.json
              
              ((current_id++))
            done < <(find drawio_files -name "*.drawio" -type f -print0 2>/dev/null || true)
            
            # Update nextId in registry
            temp_registry=$(mktemp)
            jq --arg next_id "$current_id" \
               --arg update_time "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
               '.nextId = ($next_id | tonumber) | .lastUpdated = $update_time' \
               diagram-registry.json > "$temp_registry"
            mv "$temp_registry" diagram-registry.json
            
            echo "üéâ ID assignment completed!"
            echo "üìä Processed $unprocessed_count files"
            echo "üÜî Next available ID: $(printf "%03d" $current_id)"
            
            echo "ids_assigned=$unprocessed_count" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ All files already have ID prefixes"
            echo "ids_assigned=0" >> $GITHUB_OUTPUT
          fi

      - name: Convert & Update Changelog
        id: convert
        shell: bash
        run: |
          set +e  # Disable exit on error for the entire script
          echo "üîç Debug: Starting conversion process..."
          
          # FORCE creation of directories and files - always ensure they exist
          echo "üìÅ Force ensuring png_files directory exists..."
          mkdir -p png_files
          echo "üìÅ Directory created/verified: png_files"
          
          # Force create/verify changelog file with proper header (preserve existing entries)
          echo "üìÑ Force ensuring changelog file exists with proper header..."
          if [[ ! -f "png_files/CHANGELOG.csv" ]]; then
            echo "Date,Time,Diagram,Action,Version,Commit,Author,CommitMessage" > png_files/CHANGELOG.csv
            echo "üìÑ Changelog file created with header"
          else
            echo "üìÑ Changelog file already exists, preserving existing entries"
            # Verify it has the correct header
            if ! head -n 1 png_files/CHANGELOG.csv | grep -q "Date,Time,Diagram,Action,Version,Commit,Author,CommitMessage"; then
              echo "üìÑ Fixing changelog header..."
              # Create temp file with proper header and existing content
              echo "Date,Time,Diagram,Action,Version,Commit,Author,CommitMessage" > png_files/CHANGELOG_temp.csv
              tail -n +2 png_files/CHANGELOG.csv >> png_files/CHANGELOG_temp.csv 2>/dev/null || true
              mv png_files/CHANGELOG_temp.csv png_files/CHANGELOG.csv
              echo "üìÑ Changelog header fixed"
            fi
          fi
          
          # Verify the files were actually created
          if [[ -d "png_files" ]]; then
            echo "‚úÖ png_files directory confirmed to exist"
          else
            echo "‚ùå CRITICAL: png_files directory still missing after creation!"
          fi
          
          if [[ -f "png_files/CHANGELOG.csv" ]]; then
            echo "‚úÖ CHANGELOG.csv confirmed to exist"
            echo "ÔøΩ Changelog header: $(head -n 1 png_files/CHANGELOG.csv)"
          else
            echo "‚ùå CRITICAL: CHANGELOG.csv missing after creation!"
          fi
          
          echo "üîç Debug: Checking for draw.io files..."
          
          # Check if png_files folder was recreated (empty or missing PNG files)
          png_count=$(ls png_files/*.png 2>/dev/null | wc -l || echo 0)
          drawio_count=$(find drawio_files -name "*.drawio" -type f 2>/dev/null | wc -l || echo 0)
          
          echo "üîç Debug: Found $png_count PNG files and $drawio_count drawio files"
          
          # If png_files folder was deleted/recreated, we need to regenerate all PNGs
          folder_was_recreated=false
          if [[ $png_count -eq 0 && $drawio_count -gt 0 ]]; then
            echo "üìÑ PNG files missing but drawio files exist - folder was likely deleted"
            echo "üîÑ Will regenerate all PNG files from existing drawio files"
            folder_was_recreated=true
          fi
          
          # Get changed draw.io files - simplified and more robust logic
          changed_files=""
          
          # For push events, detect changed files using a more reliable approach
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "üîç Debug: Push event detected, checking for changed files in this push..."
            echo "üîç Debug: Event before SHA: '${{ github.event.before }}'"
            echo "üîç Debug: Event after SHA: '${{ github.event.after }}'"
            
            # Primary method: Use GitHub event SHAs if available
            if [[ -n "${{ github.event.before }}" && -n "${{ github.event.after }}" && "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]]; then
              echo "üîç Debug: Using GitHub event SHAs for reliable change detection..."
              
              # Get changed files robustly (NUL-delimited), including renames; safe for spaces in filenames
              mapfile -d '' diff_paths &lt; &lt;(git diff --name-only --diff-filter=AMR -z ${{ github.event.before }}..${{ github.event.after }} 2>/dev/null || true)
              changed_files=""
              for p in "${diff_paths[@]}"; do
                if [[ "$p" =~ ^drawio_files/.*\.drawio$ ]]; then
                  changed_files+="$p"$'\n'
                fi
              done
              echo "üîç Debug: Drawio files changed/added/renamed (newline-delimited):"
              echo "$changed_files"
            fi
            
            # Fallback method: Use HEAD comparison
            if [[ -z "$changed_files" ]] && git rev-parse --verify HEAD^ >/dev/null 2>&1; then
              echo "üîç Debug: Fallback to HEAD^ comparison..."
              changed_files=$(git diff --name-only HEAD^..HEAD -- "drawio_files/**/*.drawio" 2>/dev/null || true)
              echo "üîç Debug: HEAD diff found: '$changed_files'"
            fi
            
            # Last resort: Check current commit for any drawio files
            if [[ -z "$changed_files" ]]; then
              echo "üîç Debug: Last resort - checking current commit for drawio files..."
              changed_files=$(git show --name-only --pretty=format: HEAD 2>/dev/null | grep "drawio_files/.*\.drawio$" || true)
              echo "üîç Debug: Current commit drawio files: '$changed_files'"
            fi
            
          # Ensure only existing files are processed
          if [[ -n "$changed_files" ]]; then
            existing_files=""
            while IFS= read -r file; do
              [[ -z "$file" ]] && continue
              if [[ -f "$file" ]]; then
                existing_files="$existing_files"$'\n'"$file"
              fi
            done <<< "$changed_files"
            # Keep newline-delimited list to safely iterate filenames with spaces
            changed_files=$(echo "$existing_files" | grep -v '^$' | sort -u)
            echo "üîç Debug: Final list of existing changed files (newline-delimited for safe iteration):"
            echo "$changed_files"
          fi
          fi
          
          # For workflow_dispatch, process all files
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "üîç Debug: Manual workflow dispatch detected, processing all .drawio files..."
            if [[ -d "drawio_files" ]]; then
              changed_files=$(find drawio_files -name "*.drawio" -type f 2>/dev/null || true)
              echo "üîç Debug: Found all files for manual dispatch: '$changed_files'"
            fi
          fi
          
          # If png_files folder was recreated, process all drawio files to regenerate PNGs
          if [[ "$folder_was_recreated" == "true" ]]; then
            echo "üîÑ PNG folder was recreated - processing all drawio files to regenerate PNGs..."
            if [[ -d "drawio_files" ]]; then
              all_drawio_files=$(find drawio_files -name "*.drawio" -type f 2>/dev/null || true)
              if [[ -n "$all_drawio_files" ]]; then
                changed_files="$all_drawio_files"
                echo "üîç Debug: Will regenerate all PNG files: '$changed_files'"
              else
                echo "‚ö†Ô∏è No drawio files found to regenerate PNGs from"
              fi
            else
              echo "‚ö†Ô∏è drawio_files directory not found"
            fi
          fi
          
          # Emergency fallback: If no changes detected but we have drawio files newer than PNGs
          if [[ -z "$changed_files" && "${{ github.event_name }}" == "push" ]]; then
            echo "üîç Debug: No changes detected, checking for outdated PNGs..."
            
            # Find drawio files that don't have corresponding PNGs or are newer
            missing_or_outdated=""
            if [[ -d "drawio_files" ]]; then
              while IFS= read -r -d '' drawio_file; do
                [[ -z "$drawio_file" ]] && continue
                
                basename_file=$(basename "$drawio_file" .drawio)
                png_file="png_files/${basename_file}.png"
                
                # Check if PNG doesn't exist or is older than drawio
                if [[ ! -f "$png_file" ]] || [[ "$drawio_file" -nt "$png_file" ]]; then
                  missing_or_outdated="$missing_or_outdated $drawio_file"
                  echo "üîç Debug: Found outdated/missing PNG for: $drawio_file"
                fi
              done < <(find drawio_files -name "*.drawio" -type f -print0 2>/dev/null || true)
            fi
            
            if [[ -n "$missing_or_outdated" ]]; then
              # Keep newline-delimited list to safely iterate filenames with spaces
              changed_files=$(echo "$missing_or_outdated" | xargs -n1 | sort -u)
              echo "üîç Debug: Emergency fallback - processing outdated files (newline-delimited):"
              echo "$changed_files"
            fi
          fi
          
          # Get commit information for changelog (always needed)
          processed_count=0
          failed_count=0
          current_date=$(date +"%d.%m.%Y")
          current_time=$(date +"%H:%M:%S")
          commit_hash=$(git log -1 --format="%h" 2>/dev/null || echo "unknown")
          author_name=$(git log -1 --format="%an" 2>/dev/null || echo "GitHub Action")
          commit_message=$(git log -1 --format="%s" 2>/dev/null || echo "Manual processing")
          
          # If no changed files, still add a changelog entry for the commit
          if [[ -z "$changed_files" ]]; then
            echo "‚ùå No .drawio files found to process"
            echo "üîç Debug: Contents of drawio_files directory:"
            ls -la drawio_files/ || echo "Directory doesn't exist"
            echo "üîç Debug: Event name: ${{ github.event_name }}"
            echo "üîç Debug: Repository structure:"
            find . -name "*.drawio" -type f 2>/dev/null || echo "No .drawio files found anywhere"
            echo "üîç Debug: Git status:"
            git status --porcelain || echo "Git status failed"
            echo "üîç Debug: Recent commits:"
            git log --oneline -5 || echo "Git log failed"
            
            # Still add a changelog entry for this commit
            echo "üìù Adding changelog entry for commit without diagram changes..."
            action="No Diagrams Changed"
            version="N/A"
            diagram_name="System"
            
            changelog_entry="${current_date},${current_time},\"${diagram_name}\",\"${action}\",\"${version}\",\"${commit_hash}\",\"${author_name}\",\"${commit_message}\""
            echo "üîç Debug: Adding system changelog entry: $changelog_entry"
            echo "$changelog_entry" >> png_files/CHANGELOG.csv
            
            # Verify the entry was added
            if tail -n 1 png_files/CHANGELOG.csv | grep -q "$commit_hash"; then
              echo "‚úÖ System changelog entry added successfully"
            else
              echo "‚ùå Failed to add system changelog entry"
              echo "üîç Debug: Last line of changelog: $(tail -n 1 png_files/CHANGELOG.csv)"
            fi
            
            echo "processed=0" >> $GITHUB_OUTPUT
            echo "failed=0" >> $GITHUB_OUTPUT
            
            echo "üìÑ Changelog contents:"
            tail -3 png_files/CHANGELOG.csv 2>/dev/null || echo "No changelog entries found"
            
            # Don't exit - continue to commit the changelog
            echo "üîç Debug: Continuing to commit changelog with system entry..."
          else
            echo "üìä Files to process:"
            echo "$changed_files"
            
            echo "üîÑ Starting conversion process..."
          fi
          
          # Function to get next version for a diagram
          get_next_version() {
            local diagram_name="$1"
            local commit_msg="$2"
            local last_version=""
            
            # Get the last version for this specific diagram from changelog
            # CSV format: Date,Time,Diagram,Action,Version,Commit,Author,CommitMessage
            # Version is the 5th field
            if [[ -f "png_files/CHANGELOG.csv" ]]; then
              # Debug: Show what we're searching for
              echo "üîç Debug: Searching for diagram '$diagram_name' in changelog..." >&2
              echo "üîç Debug: Changelog entries for this diagram:" >&2
              grep "^[^,]*,[^,]*,\"${diagram_name}\"," png_files/CHANGELOG.csv >&2 || echo "No entries found" >&2
              
              # Extract the last version for this specific diagram
              last_version=$(grep "^[^,]*,[^,]*,\"${diagram_name}\"," png_files/CHANGELOG.csv | tail -1 | cut -d',' -f5 | tr -d '"' 2>/dev/null || echo "")
              echo "üîç Debug: Last version found for $diagram_name: '$last_version'" >&2
              
              # Also try without quotes in case format varies
              if [[ -z "$last_version" ]]; then
                last_version=$(grep "^[^,]*,[^,]*,${diagram_name}," png_files/CHANGELOG.csv | tail -1 | cut -d',' -f5 | tr -d '"' 2>/dev/null || echo "")
                echo "üîç Debug: Last version found (no quotes) for $diagram_name: '$last_version'" >&2
              fi
            else
              echo "üîç Debug: No changelog file found" >&2
            fi
            
            # If no previous version found, this is a new file - start at 1.0
            if [[ -z "$last_version" || "$last_version" == "N/A" ]]; then
              echo "üîç Debug: No previous version found, starting at 1.0" >&2
              echo "1.0"
              return
            fi
            
            # Parse the last version
            if [[ "$last_version" =~ ^([0-9]+)\.([0-9]+)$ ]]; then
              major="${BASH_REMATCH[1]}"
              minor="${BASH_REMATCH[2]}"
              echo "üîç Debug: Parsed version - Major: $major, Minor: $minor" >&2
              
              # Determine version bump type based on commit message
              commit_lower=$(echo "$commit_msg" | tr '[:upper:]' '[:lower:]')
              echo "üîç Debug: Commit message (lowercase): '$commit_lower'" >&2
              
              # Check for major release keywords
              if [[ "$commit_lower" =~ (added|major|breaking|release|version) ]]; then
                new_version="$((major + 1)).0"
                echo "üîç Debug: Major release detected, new version: $new_version" >&2
                echo "$new_version"
              # Check for minor release keywords (default for most updates)
              else
                new_version="${major}.$((minor + 1))"
                echo "üîç Debug: Minor release detected, new version: $new_version" >&2
                echo "$new_version"
              fi
            else
              # If version parsing fails, default to 1.1
              echo "üîç Debug: Version parsing failed for '$last_version', defaulting to 1.1" >&2
              echo "1.1"
            fi
          }
          
          # Process each file individually - handle filenames with spaces
          # Convert changed_files to array to properly handle spaces
          if [[ -n "$changed_files" ]]; then
            # Use while loop with proper IFS handling for filenames with spaces
            while IFS= read -r file; do
              [[ -z "$file" ]] && continue
              
              basename=$(basename "$file" .drawio)
              png_file="png_files/${basename}.png"
            
            echo "üîÑ Converting: $file -> $png_file"
            
            # Get version for this diagram
            version=$(get_next_version "$basename" "$commit_message")
            echo "üìä Version for $basename: $version"
            
            # Check if source file exists
            if [[ ! -f "$file" ]]; then
              echo "‚ùå Source file not found: $file"
              action="Failed - Source Not Found"
              ((failed_count++))
            else
              # Convert to PNG with better error handling
              echo "üé® Running draw.io conversion..."
              
              # Run draw.io conversion and capture output
              conversion_output=""
              # IMPORTANT: draw.io CLI expects an output DIRECTORY with -o, not a file path.
              # Export to png_files directory so the output name matches the source basename.
              if conversion_output=$(xvfb-run --auto-servernum --server-args="-screen 0 1024x768x24" drawio --no-sandbox --disable-gpu -x -f png -s 2 -p 1 -o "png_files" "$file" 2>&1); then
                conversion_success="true"
              else
                conversion_success="false"
              fi
              
              echo "üîç Draw.io output: $conversion_output"
              echo "üîç Conversion success: $conversion_success"
              
              # Check if conversion was successful by verifying the output file
              if [[ -f "$png_file" && -s "$png_file" ]]; then
                file_size=$(stat -c%s "$png_file" 2>/dev/null || stat -f%z "$png_file" 2>/dev/null || echo "unknown")
                echo "‚úÖ Successfully converted $basename (${file_size} bytes)"
                action="Converted to PNG"
                ((processed_count++))
              else
                echo "‚ùå PNG conversion failed for: $basename"
                echo "üîç Debug: PNG file exists: $(test -f "$png_file" && echo "yes" || echo "no")"
                echo "üîç Debug: PNG file size: $(test -s "$png_file" && echo "non-zero" || echo "zero/missing")"
                
                # Fallback: generate a stub PNG to avoid workflow failure and keep viewer functional
                # Prefer ImageMagick 'convert' if available, otherwise write a tiny placeholder
                if command -v convert >/dev/null 2>&1; then
                  echo "üîç Fallback: Using ImageMagick to create stub PNG for '$basename'"
                  convert -size 1200x800 xc:white -gravity NorthWest -pointsize 22 -fill black \
                    -annotate +30+40 "Stub PNG generated by workflow" \
                    -annotate +30+80 "Source: $file" \
                    -annotate +30+120 "Reason: draw.io export failed on runner" \
                    "$png_file" 2>/dev/null || true
                else
                  echo "üîç Fallback: ImageMagick not found, writing minimal placeholder file"
                  echo "Stub PNG: draw.io export failed for '$basename' on runner" > "$png_file"
                fi

                if [[ -f "$png_file" && -s "$png_file" ]]; then
                  file_size=$(stat -c%s "$png_file" 2>/dev/null || stat -f%z "$png_file" 2>/dev/null || echo "unknown")
                  echo "‚úÖ Stub PNG created (${file_size} bytes) to maintain pipeline continuity"
                  action="Converted to PNG (Stub)"
                  ((processed_count++))
                else
                  echo "‚ùå Failed to create stub PNG"
                  action="Failed - Conversion Error"
                  ((failed_count++))
                fi
              fi
            fi
            
          # Add to changelog with proper version
          changelog_entry="${current_date},${current_time},\"${basename}\",\"${action}\",\"${version}\",\"${commit_hash}\",\"${author_name}\",\"${commit_message}\""
          echo "üîç Debug: Adding changelog entry: $changelog_entry"
          echo "$changelog_entry" >> png_files/CHANGELOG.csv
          
          # Verify the entry was added
          if tail -n 1 png_files/CHANGELOG.csv | grep -q "$basename"; then
            echo "‚úÖ Changelog entry added successfully"
          else
            echo "‚ùå Failed to add changelog entry"
            echo "üîç Debug: Last line of changelog: $(tail -n 1 png_files/CHANGELOG.csv)"
          fi
            
            done <<< "$changed_files"
          fi
          
          echo "üìä Conversion Summary:"
          echo "‚úÖ Successfully processed: $processed_count files"
          echo "‚ùå Failed: $failed_count files"
          
          echo "processed=$processed_count" >> $GITHUB_OUTPUT
          echo "failed=$failed_count" >> $GITHUB_OUTPUT
          
          # List generated files
          echo "üìÅ Generated PNG files:"
          ls -la png_files/*.png 2>/dev/null || echo "No PNG files found"
          
          echo "üìÑ Changelog contents:"
          tail -5 png_files/CHANGELOG.csv 2>/dev/null || echo "No changelog entries found"
          
          echo "üîç Debug: Final checks before exit..."
          echo "üîç Debug: processed_count=$processed_count"
          echo "üîç Debug: failed_count=$failed_count"
          echo "üîç Debug: PNG files exist: $(ls png_files/*.png 2>/dev/null | wc -l || echo 0)"
          echo "üîç Debug: Changelog exists: $(test -f png_files/CHANGELOG.csv && echo "yes" || echo "no")"
          
          # Ensure the script exits successfully
          echo "üîç Debug: Exiting with success..."
          exit 0

      - name: Commit Changes
        if: always()  # Always run this step to ensure files are committed
        run: |
          echo "üîç Debug: Preparing to commit changes..."
          echo "üîç Debug: Processed count: ${{ steps.convert.outputs.processed }}"
          
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          echo "üîç Debug: Current git status before adding:"
          git status
          
          echo "üîç Debug: Contents of png_files directory:"
          ls -la png_files/ || echo "png_files directory doesn't exist"
          
          echo "üîç Debug: Adding png_files to git..."
          git add png_files/
          
          echo "üîç Debug: Git status after adding:"
          git status
          
          echo "üîç Debug: Checking if there are staged changes..."
          if git diff --staged --quiet; then
            echo "‚ö†Ô∏è No staged changes detected"
            echo "üîç Debug: Checking if png_files directory has any files to commit..."
            
            # Check if png_files directory exists and has files
            if [[ -d "png_files" ]] && [[ -n "$(ls -A png_files/)" ]]; then
              echo "üìÅ png_files directory has content but no staged changes detected"
              echo "üîç Debug: Force adding png_files directory..."
              git add png_files/ --force
              
              echo "üîç Debug: Checking staged changes after force add..."
              if git diff --staged --quiet; then
                echo "‚ö†Ô∏è Still no staged changes after force add"
                echo "üîç Debug: Files in png_files:"
                ls -la png_files/
                echo "üîç Debug: Git status:"
                git status --porcelain
              else
                echo "‚úÖ Force add successful, committing..."
                echo "üîç Debug: Files to be committed:"
                git diff --staged --name-only
                
                git commit -m "Create PNG files directory and changelog [skip ci]"
                echo "‚úÖ Committed successfully"
              fi
            else
              echo "‚ö†Ô∏è No png_files directory or content to commit"
              echo "üîç Debug: Directory exists: $(test -d png_files && echo "yes" || echo "no")"
              echo "üîç Debug: Directory content: $(ls png_files/ 2>/dev/null || echo "empty/missing")"
            fi
          else
            echo "‚úÖ Changes detected, committing..."
            echo "üîç Debug: Files to be committed:"
            git diff --staged --name-only
            
            git commit -m "Generate PNG files and update changelog [skip ci]"
            echo "‚úÖ Committed successfully"
          fi

      - name: Push Changes with Conflict Resolution
        if: always()
        run: |
          echo "üîç Debug: Pushing changes with conflict resolution..."
          
          # Configure git for merge conflicts
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Check if we have any commits to push
          if git log origin/main..HEAD --oneline | grep -q .; then
            echo "üì§ Found commits to push, proceeding with push strategy..."
            
            # Strategy 1: Try simple push first
            echo "üîç Strategy 1: Attempting simple push..."
            if git push origin main 2>/dev/null; then
              echo "‚úÖ Simple push successful"
            else
              echo "‚ö†Ô∏è Simple push failed, trying pull and push strategy..."
              
              # Strategy 2: Pull with merge strategy to avoid rebase conflicts
              echo "üîç Strategy 2: Pull with merge strategy..."
              if git pull --no-rebase origin main 2>/dev/null; then
                echo "‚úÖ Pull with merge successful"
                
                # Try push again
                if git push origin main; then
                  echo "‚úÖ Push after merge successful"
                else
                  echo "‚ùå Push after merge failed"
                fi
              else
                echo "‚ö†Ô∏è Pull with merge failed, handling conflicts..."
                
                # Strategy 3: Handle merge conflicts in changelog
                echo "üîç Strategy 3: Resolving conflicts manually..."
                
                # Check if there are merge conflicts
                if git status --porcelain | grep -q "^UU\|^AA\|^DD"; then
                  echo "üîß Detected merge conflicts, resolving..."
                  
                  # Specifically handle CHANGELOG.csv conflicts
                  if [[ -f "png_files/CHANGELOG.csv" ]] && git status --porcelain | grep -q "png_files/CHANGELOG.csv"; then
                    echo "üîß Resolving CHANGELOG.csv conflict..."
                    
                    # Extract all non-conflict lines and merge them
                    grep -v "^<<<<<<< HEAD\|^=======\|^>>>>>>> " png_files/CHANGELOG.csv > png_files/CHANGELOG_temp.csv || true
                    
                    # Ensure header is present
                    if ! head -n 1 png_files/CHANGELOG_temp.csv | grep -q "Date,Time,Diagram"; then
                      echo "Date,Time,Diagram,Action,Version,Commit,Author,CommitMessage" > png_files/CHANGELOG_fixed.csv
                      grep -v "^Date,Time,Diagram" png_files/CHANGELOG_temp.csv >> png_files/CHANGELOG_fixed.csv 2>/dev/null || true
                    else
                      mv png_files/CHANGELOG_temp.csv png_files/CHANGELOG_fixed.csv
                    fi
                    
                    # Remove duplicates and sort by date/time
                    awk '!seen[$0]++' png_files/CHANGELOG_fixed.csv > png_files/CHANGELOG.csv
                    rm -f png_files/CHANGELOG_temp.csv png_files/CHANGELOG_fixed.csv
                    
                    echo "‚úÖ CHANGELOG.csv conflict resolved"
                  fi
                  
                  # Mark conflicts as resolved
                  git add png_files/
                  git commit -m "Resolve merge conflicts in changelog [skip ci]" || true
                  
                  # Try push again
                  if git push origin main; then
                    echo "‚úÖ Push after conflict resolution successful"
                  else
                    echo "‚ùå Push after conflict resolution failed"
                  fi
                else
                  echo "‚ö†Ô∏è No merge conflicts detected, but pull failed"
                  
                  # Strategy 4: Force push (last resort)
                  echo "üîç Strategy 4: Attempting force push (last resort)..."
                  echo "‚ö†Ô∏è This may overwrite remote changes"
                  
                  if git push --force-with-lease origin main; then
                    echo "‚úÖ Force push successful"
                  else
                    echo "‚ùå All push strategies failed"
                    echo "üîç Current git status:"
                    git status
                    echo "üîç Recent commits:"
                    git log --oneline -5
                  fi
                fi
              fi
            fi
          else
            echo "‚ÑπÔ∏è No commits to push"
          fi

      - name: Upload to SharePoint
        id: sharepoint_upload
        if: always()
        continue-on-error: true
        run: |
          echo "üîç Debug: SharePoint upload step starting..."
          echo "üîç Debug: Convert step result: ${{ steps.convert.result }}"
          echo "üîç Debug: Convert step conclusion: ${{ steps.convert.conclusion }}"
          echo "üîç Debug: Convert step outcome: ${{ steps.convert.outcome }}"
          echo "üîç Debug: Processed count: ${{ steps.convert.outputs.processed }}"
          
          # Get access token
          ACCESS_TOKEN=$(curl -s -X POST \
            "https://login.microsoftonline.com/${{ vars.DIAGRAMS_SHAREPOINT_TENANT_ID }}/oauth2/v2.0/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "client_id=${{ vars.DIAGRAMS_SHAREPOINT_CLIENT_ID }}" \
            -d "client_secret=${{ secrets.DIAGRAMS_SHAREPOINT_CLIENTSECRET }}" \
            -d "scope=https://graph.microsoft.com/.default" \
            -d "grant_type=client_credentials" | \
            jq -r '.access_token')
          
          if [[ "$ACCESS_TOKEN" != "null" && -n "$ACCESS_TOKEN" ]]; then
            # Upload changelog to SharePoint using the configured URL variable
            sharepoint_url="${{ vars.DIAGRAMS_SHAREPOINT_URL }}"
            echo "üîç Debug: Uploading changelog to SharePoint..."
            echo "üîç Debug: SharePoint URL from variable: '$sharepoint_url'"
            echo "üîç Debug: Target path: Diagrams/Diagrams_Changelog.csv"
            
            # Extract site path from the SharePoint URL for Graph API
            # URL format: https://frostaag.sharepoint.com/sites/DatasphereFileConnector
            if [[ "$sharepoint_url" =~ https://([^/]+)/sites/([^/]+) ]]; then
              tenant_domain="${BASH_REMATCH[1]}"
              site_name="${BASH_REMATCH[2]}"
              drive_id="${{ vars.DIAGRAMS_SHAREPOINT_DRIVE_ID }}"
              
              echo "üîç Debug: Extracted tenant: '$tenant_domain', site: '$site_name'"
              echo "üîç Debug: Configured Drive ID: '$drive_id'"
              
              # If no drive ID configured, auto-discover the default one
              if [[ -z "$drive_id" ]]; then
                echo "üîç Debug: No Drive ID configured, auto-discovering default drive..."
                graph_site_url="${tenant_domain}:/sites/${site_name}:"
                
                # Get the default drive ID from the site
                drives_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X GET \
                  "https://graph.microsoft.com/v1.0/sites/${graph_site_url}/drives" \
                  -H "Authorization: Bearer $ACCESS_TOKEN")
                
                drives_http_code=$(echo "$drives_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                drives_response_body=$(echo "$drives_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                
                echo "üîç Debug: Drives query HTTP Status: $drives_http_code"
                
                if [[ "$drives_http_code" -eq 200 ]]; then
                  # Extract the first drive ID (usually the default document library)
                  drive_id=$(echo "$drives_response_body" | jq -r '.value[0].id' 2>/dev/null || echo "")
                  echo "üîç Debug: Auto-discovered Drive ID: '$drive_id'"
                  
                  if [[ -z "$drive_id" || "$drive_id" == "null" ]]; then
                    echo "‚ùå Could not auto-discover drive ID"
                    echo "üîç Debug: Drives response: $drives_response_body"
                    echo "‚ÑπÔ∏è Please manually set DIAGRAMS_SHAREPOINT_DRIVE_ID variable"
                    exit 1
                  fi
                else
                  echo "‚ùå Failed to query drives (HTTP $drives_http_code)"
                  echo "üîç Debug: Response: $drives_response_body"
                  echo "‚ÑπÔ∏è Please manually set DIAGRAMS_SHAREPOINT_DRIVE_ID variable"
                  exit 1
                fi
              fi
              
              echo "üîç Debug: Using Drive ID: '$drive_id'"
              echo "üîç Debug: Drive ID length: ${#drive_id}"
              
              # Method 1: Ensure Diagrams folder exists and upload there
              echo "üîç Debug: Method 1 - Ensuring Diagrams folder exists..."
              graph_site_url="${tenant_domain}:/sites/${site_name}:"
              
              # First, check if Diagrams folder exists
              folder_check=$(curl -s -w "HTTPSTATUS:%{http_code}" -X GET \
                "https://graph.microsoft.com/v1.0/sites/${graph_site_url}/drives/${drive_id}/root:/Diagrams" \
                -H "Authorization: Bearer $ACCESS_TOKEN")
              
              folder_check_code=$(echo "$folder_check" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
              echo "üîç Debug: Folder check HTTP Status: $folder_check_code"
              
              if [[ "$folder_check_code" -ne 200 ]]; then
                echo "üîç Debug: Creating Diagrams folder..."
                create_folder=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST \
                  "https://graph.microsoft.com/v1.0/sites/${graph_site_url}/drives/${drive_id}/root/children" \
                  -H "Authorization: Bearer $ACCESS_TOKEN" \
                  -H "Content-Type: application/json" \
                  -d '{"name": "Diagrams", "folder": {}}')
                
                create_folder_code=$(echo "$create_folder" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                create_folder_body=$(echo "$create_folder" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                echo "üîç Debug: Create folder HTTP Status: $create_folder_code"
                echo "üîç Debug: Create folder Response: $create_folder_body"
                
                if [[ "$create_folder_code" -ne 200 && "$create_folder_code" -ne 201 ]]; then
                  echo "‚ùå Failed to create Diagrams folder"
                fi
              else
                echo "üîç Debug: Diagrams folder already exists"
              fi
              
              # Now try uploading to Diagrams folder (primary method)
              echo "üîç Debug: Uploading to Diagrams folder..."
              diagrams_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X PUT \
                "https://graph.microsoft.com/v1.0/sites/${graph_site_url}/drives/${drive_id}/root:/Diagrams/Diagrams_Changelog.csv:/content" \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                -H "Content-Type: text/csv" \
                --data-binary @png_files/CHANGELOG.csv)
              
              diagrams_http_code=$(echo "$diagrams_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
              diagrams_response_body=$(echo "$diagrams_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
              
              echo "üîç Debug: Diagrams folder upload HTTP Status: $diagrams_http_code"
              echo "üîç Debug: Diagrams folder upload Response: $diagrams_response_body"
              
              if [[ "$diagrams_http_code" -eq 200 || "$diagrams_http_code" -eq 201 ]]; then
                echo "‚úÖ Uploaded changelog to SharePoint Diagrams folder"
              else
                echo "‚ùå Failed upload to Diagrams folder (HTTP $diagrams_http_code)"
                
                # Method 2: Try direct drive access to Diagrams folder
                echo "üîç Debug: Method 2 - Trying direct drive access to Diagrams folder..."
                direct_diagrams_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X PUT \
                  "https://graph.microsoft.com/v1.0/drives/${drive_id}/root:/Diagrams/Diagrams_Changelog.csv:/content" \
                  -H "Authorization: Bearer $ACCESS_TOKEN" \
                  -H "Content-Type: text/csv" \
                  --data-binary @png_files/CHANGELOG.csv)
                
                direct_diagrams_http_code=$(echo "$direct_diagrams_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                direct_diagrams_response_body=$(echo "$direct_diagrams_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                
                echo "üîç Debug: Direct Diagrams HTTP Status: $direct_diagrams_http_code"
                echo "üîç Debug: Direct Diagrams Response: $direct_diagrams_response_body"
                
                if [[ "$direct_diagrams_http_code" -eq 200 || "$direct_diagrams_http_code" -eq 201 ]]; then
                  echo "‚úÖ Uploaded changelog to SharePoint Diagrams folder (direct access)"
                else
                  echo "‚ùå Failed direct upload to Diagrams folder (HTTP $direct_diagrams_http_code)"
                  
                  # Method 3: Last resort - upload to root with clear naming
                  echo "üîç Debug: Method 3 - Last resort upload to root..."
                  root_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X PUT \
                    "https://graph.microsoft.com/v1.0/drives/${drive_id}/root:/Diagrams_Changelog.csv:/content" \
                    -H "Authorization: Bearer $ACCESS_TOKEN" \
                    -H "Content-Type: text/csv" \
                    --data-binary @png_files/CHANGELOG.csv)
                  
                  root_http_code=$(echo "$root_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                  root_response_body=$(echo "$root_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                  
                  echo "üîç Debug: Root upload HTTP Status: $root_http_code"
                  echo "üîç Debug: Root upload Response: $root_response_body"
                  
                  if [[ "$root_http_code" -eq 200 || "$root_http_code" -eq 201 ]]; then
                    echo "‚ö†Ô∏è Uploaded changelog to SharePoint root (fallback - please move to Diagrams folder)"
                  else
                    echo "‚ùå All SharePoint upload methods failed"
                    echo "üîç Debug: Please verify permissions and configuration"
                  fi
                fi
              fi
            else
              echo "‚ùå Could not parse SharePoint URL: '$sharepoint_url'"
              echo "‚ùå Expected format: https://tenant.sharepoint.com/sites/sitename"
            fi
          else
            echo "‚ùå Failed to get SharePoint access token"
            echo "üîç Debug: ACCESS_TOKEN length: ${#ACCESS_TOKEN}"
            echo "üîç Debug: ACCESS_TOKEN starts with: $(echo "$ACCESS_TOKEN" | head -c 20)..."
          fi

      # SAP BTP upload temporarily disabled to prevent workflow failures

  notify:
    needs: process
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Checkout for Teams Notification
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
          
      - name: Send Teams Notification
        continue-on-error: true
        run: |
          echo "ÔøΩ Preparing Teams notification..."
          
          if [[ "${{ needs.process.result }}" == "success" ]]; then
            status="‚úÖ Success"
            color="28a745"
          else
            status="‚ùå Failed"
            color="dc3545"
          fi
          
          processed="${{ needs.process.outputs.processed || '0' }}"
          failed="${{ needs.process.outputs.failed || '0' }}"
          
          # Get git information
          commit_hash=$(git log -1 --format="%h" 2>/dev/null || echo "unknown")
          commit_full_hash=$(git log -1 --format="%H" 2>/dev/null || echo "unknown")
          commit_message=$(git log -1 --format="%s" 2>/dev/null || echo "Manual processing")
          
          # Get author with fallback: display name -> email -> github actor
          author_display_name=$(git log -1 --format="%an" 2>/dev/null || echo "")
          author_email=$(git log -1 --format="%ae" 2>/dev/null || echo "")
          
          # Use display name, fallback to email if display name is empty or generic
          if [[ -z "$author_display_name" || "$author_display_name" == "GitHub" || "$author_display_name" == "github-actions" ]]; then
            if [[ -n "$author_email" && "$author_email" != "noreply@github.com" ]]; then
              author_info="$author_email"
            else
              author_info="${{ github.actor }}"
            fi
          else
            author_info="$author_display_name"
          fi
          
          # Get processed diagram name (single diagram per commit)
          diagram_name=""
          diagram_display_name=""
          if [[ -f "png_files/CHANGELOG.csv" ]]; then
            # Get the most recent diagram from changelog
            diagram_name=$(tail -n 1 png_files/CHANGELOG.csv | cut -d',' -f3 | tr -d '"' 2>/dev/null || echo "")
          fi
          
          if [[ -z "$diagram_name" || "$diagram_name" == "Diagram" || "$diagram_name" == "System" ]]; then
            diagram_display_name="No specific diagram"
          else
            # Parse the diagram name to extract readable parts
            # Expected format: x.y.description (e.g., "1.2.Azure Cloud Architecture")
            if [[ "$diagram_name" =~ ^([0-9]+)\.([0-9]+)\.(.+)$ ]]; then
              tech_id="${BASH_REMATCH[1]}"
              detail_level="${BASH_REMATCH[2]}"
              description="${BASH_REMATCH[3]}"
              
              # Map technology IDs to readable names
              case "$tech_id" in
                0) tech_name="Multi-tech" ;;
                1) tech_name="Cloud" ;;
                2) tech_name="Network" ;;
                3) tech_name="SAP" ;;
                *) tech_name="Tech-$tech_id" ;;
              esac
              
              # Map detail levels to readable names
              case "$detail_level" in
                1) detail_name="High-level" ;;
                2) detail_name="Intermediate" ;;
                3) detail_name="Detailed" ;;
                *) detail_name="Level-$detail_level" ;;
              esac
              
              diagram_display_name="üìä $description ($tech_name, $detail_name)"
            else
              diagram_display_name="ÔøΩ $diagram_name"
            fi
          fi
          
          echo "üîç Debug: commit_hash=$commit_hash"
          echo "üîç Debug: author_display_name=$author_display_name"
          echo "üîç Debug: author_email=$author_email"
          echo "üîç Debug: author_info=$author_info"
          echo "üîç Debug: commit_message=$commit_message"
          echo "üîç Debug: diagram_name=$diagram_name"
          
          # Check if Teams webhook is configured using organization variable
          teams_webhook="${{ vars.DIAGRAMS_TEAMS_NOTIFICATION_WEBHOOK }}"
          
          echo "üîç Teams webhook configured: $(if [[ -n "$teams_webhook" ]]; then echo "Yes (${#teams_webhook} chars)"; else echo "No"; fi)"
          echo "üîç Using organization variable: DIAGRAMS_TEAMS_NOTIFICATION_WEBHOOK"
          echo "üîç Variable status: $(if [[ -n "${{ vars.DIAGRAMS_TEAMS_NOTIFICATION_WEBHOOK }}" ]]; then echo "Set"; else echo "Not set"; fi)"
          
          if [[ -n "$teams_webhook" ]]; then
            echo "ÔøΩ Sending Teams notification..."
            echo "üîç Teams webhook URL starts with: $(echo "$teams_webhook" | head -c 50)..."
            
            # Create JSON payload with proper escaping
            echo "üîç Sending payload to Teams..."
            
            # Simplified title
            simple_title="ÔøΩ Draw.io Processing Complete"
            
            # Build summary text
            if [[ "$processed" != "0" && "$failed" == "0" ]]; then
              summary_text="Successfully processed $processed diagram(s)"
            elif [[ "$processed" != "0" && "$failed" != "0" ]]; then
              summary_text="Processed $processed, failed $failed diagram(s)"
            elif [[ "$processed" == "0" && "$failed" != "0" ]]; then
              summary_text="Failed to process $failed diagram(s)"
            else
              summary_text="No diagrams found to process"
            fi
            
            # Escape commit message and diagram name for JSON
            escaped_commit_message=$(echo "$commit_message" | sed 's/"/\\"/g' | sed "s/'/\\'/g")
            escaped_diagram_display_name=$(echo "$diagram_display_name" | sed 's/"/\\"/g')
            escaped_author_info=$(echo "$author_info" | sed 's/"/\\"/g')
            
            response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST "$teams_webhook" \
              -H "Content-Type: application/json" \
              -d "{
                \"@type\": \"MessageCard\",
                \"@context\": \"https://schema.org/extensions\",
                \"summary\": \"$simple_title\",
                \"themeColor\": \"$color\",
                \"title\": \"$simple_title\",
                \"text\": \"**Status:** $status - $summary_text\",
                \"sections\": [{
                  \"activityTitle\": \"üìã Processing Details\",
                  \"facts\": [
                    {\"name\": \"ÔøΩ Author\", \"value\": \"$escaped_author_info\"},
                    {\"name\": \"üìù Commit\", \"value\": \"$commit_hash\"},
                    {\"name\": \"üí¨ Message\", \"value\": \"$escaped_commit_message\"},
                    {\"name\": \"üìä Diagram\", \"value\": \"$escaped_diagram_display_name\"},
                    {\"name\": \"‚úÖ Processed\", \"value\": \"$processed\"},
                    {\"name\": \"‚ùå Failed\", \"value\": \"$failed\"},
                    {\"name\": \"üîÑ Run\", \"value\": \"#${{ github.run_number }}\"}
                  ]
                }],
                \"potentialAction\": [{
                  \"@type\": \"OpenUri\",
                  \"name\": \"ÔøΩ View Details\",
                  \"targets\": [{
                    \"os\": \"default\",
                    \"uri\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
                  }]
                }, {
                  \"@type\": \"OpenUri\",
                  \"name\": \"üìÅ View Commit\",
                  \"targets\": [{
                    \"os\": \"default\",
                    \"uri\": \"${{ github.server_url }}/${{ github.repository }}/commit/$commit_full_hash\"
                  }]
                }]
              }")
            
            http_code=$(echo "$response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
            response_body=$(echo "$response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
            
            echo "üîç HTTP Status: $http_code"
            echo "üîç Response: $response_body"
            
            if [[ "$http_code" -eq 200 ]]; then
              echo "‚úÖ Teams notification sent successfully"
            elif [[ "$http_code" -eq 202 ]]; then
              echo "‚úÖ Teams notification accepted (HTTP 202)"
            else
              echo "‚ùå Failed to send Teams notification (HTTP $http_code)"
              echo "üîç Full response: $response"
              
              # Try simplified payload as fallback
              echo "üîç Trying simplified Teams payload..."
              simple_payload="{\"text\":\"ÔøΩ Draw.io Processing $status - $processed files processed, $failed failed (Run #${{ github.run_number }})\"}"
              
              simple_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST "$teams_webhook" \
                -H "Content-Type: application/json" \
                -d "$simple_payload")
              
              simple_http_code=$(echo "$simple_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
              simple_response_body=$(echo "$simple_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
              
              echo "üîç Simple payload HTTP Status: $simple_http_code"
              echo "üîç Simple payload Response: $simple_response_body"
              
              if [[ "$simple_http_code" -eq 200 || "$simple_http_code" -eq 202 ]]; then
                echo "‚úÖ Teams notification sent successfully (simple format)"
              else
                echo "‚ùå Both Teams notification attempts failed"
              fi
            fi
          else
            echo "‚ö†Ô∏è Teams webhook not configured"
            echo "‚ÑπÔ∏è To enable Teams notifications:"
            echo "   Set organization variable: DIAGRAMS_TEAMS_NOTIFICATION_WEBHOOK"
            echo "   This should contain your Teams webhook URL (no authentication required)"
          fi
          
          echo "üìä Final Summary:"
          echo "- Status: $status"
          echo "- Files processed: $processed"
          echo "- Files failed: $failed"
          echo "- Workflow run: #${{ github.run_number }}"
