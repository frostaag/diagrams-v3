name: Draw.io to PNG Processing V3

on:
  push:
    paths:
      - 'drawio_files/**/*.drawio'
      - 'drawio_files/**'  # Also trigger on folder changes
  workflow_dispatch:

env:
  DRAWIO_VERSION: "26.2.2"

permissions:
  contents: write

jobs:
  process:
    runs-on: ubuntu-latest
    outputs:
      processed: ${{ steps.convert.outputs.processed }}
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Draw.io
        run: |
          sudo apt-get update
          sudo apt-get install -y wget xvfb
          wget -q "https://github.com/jgraph/drawio-desktop/releases/download/v${{ env.DRAWIO_VERSION }}/drawio-amd64-${{ env.DRAWIO_VERSION }}.deb"
          sudo apt-get install -y "./drawio-amd64-${{ env.DRAWIO_VERSION }}.deb"

      - name: Convert & Update Changelog
        id: convert
        shell: bash
        run: |
          set +e  # Disable exit on error for the entire script
          echo "🔍 Debug: Starting conversion process..."
          
          # FORCE creation of directories and files - always ensure they exist
          echo "📁 Force ensuring png_files directory exists..."
          mkdir -p png_files
          echo "📁 Directory created/verified: png_files"
          
          # Force create/verify changelog file with proper header
          echo "📄 Force ensuring changelog file exists with proper header..."
          echo "Date,Time,Diagram,Action,Version,Commit,Author,CommitMessage" > png_files/CHANGELOG.csv
          echo "📄 Changelog file created/reset with proper header"
          
          # Verify the files were actually created
          if [[ -d "png_files" ]]; then
            echo "✅ png_files directory confirmed to exist"
          else
            echo "❌ CRITICAL: png_files directory still missing after creation!"
          fi
          
          if [[ -f "png_files/CHANGELOG.csv" ]]; then
            echo "✅ CHANGELOG.csv confirmed to exist"
            echo "� Changelog header: $(head -n 1 png_files/CHANGELOG.csv)"
          else
            echo "❌ CRITICAL: CHANGELOG.csv missing after creation!"
          fi
          
          echo "🔍 Debug: Checking for draw.io files..."
          
          # Check if png_files folder was recreated (empty or missing PNG files)
          png_count=$(ls png_files/*.png 2>/dev/null | wc -l || echo 0)
          drawio_count=$(find drawio_files -name "*.drawio" -type f 2>/dev/null | wc -l || echo 0)
          
          echo "🔍 Debug: Found $png_count PNG files and $drawio_count drawio files"
          
          # If png_files folder was deleted/recreated, we need to regenerate all PNGs
          folder_was_recreated=false
          if [[ $png_count -eq 0 && $drawio_count -gt 0 ]]; then
            echo "📄 PNG files missing but drawio files exist - folder was likely deleted"
            echo "🔄 Will regenerate all PNG files from existing drawio files"
            folder_was_recreated=true
          fi
          
          # Get changed draw.io files - improved logic for only changed files
          changed_files=""
          
          # For push events, only process files that were actually changed in this commit
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "🔍 Debug: Push event detected, checking for changed files in this push..."
            echo "🔍 Debug: Event before SHA: '${{ github.event.before }}'"
            echo "🔍 Debug: Event after SHA: '${{ github.event.after }}'"
            
            # Try multiple methods to get changed files
            # Method 1: Use GitHub event before/after SHAs
            if [[ -n "${{ github.event.before }}" && -n "${{ github.event.after }}" && "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]]; then
              echo "🔍 Debug: Using GitHub event SHAs..."
              changed_files=$(git diff --name-only ${{ github.event.before }}..${{ github.event.after }} -- "drawio_files/**/*.drawio" 2>/dev/null || true)
              echo "🔍 Debug: GitHub event diff found: '$changed_files'"
            fi
            
            # Method 2: Fallback to HEAD^ comparison
            if [[ -z "$changed_files" ]] && git rev-parse --verify HEAD^ >/dev/null 2>&1; then
              echo "🔍 Debug: Fallback - checking git diff HEAD^..HEAD..."
              changed_files=$(git diff --name-only HEAD^..HEAD -- "drawio_files/**/*.drawio" 2>/dev/null || true)
              echo "🔍 Debug: HEAD diff found: '$changed_files'"
            fi
            
            # Method 3: Use git log to find files changed in last commit
            if [[ -z "$changed_files" ]]; then
              echo "🔍 Debug: Using git log method..."
              changed_files=$(git log -1 --name-only --pretty=format: -- "drawio_files/**/*.drawio" 2>/dev/null | grep -v '^$' || true)
              echo "🔍 Debug: Git log found: '$changed_files'"
            fi
            
            # Method 4: Use git show to get files from current commit
            if [[ -z "$changed_files" ]]; then
              echo "🔍 Debug: Using git show method..."
              changed_files=$(git show --name-only --pretty=format: HEAD -- "drawio_files/**/*.drawio" 2>/dev/null | grep -v '^$' || true)
              echo "🔍 Debug: Git show found: '$changed_files'"
            fi
            
            # Method 5: Check for files modified in the push using git log with range
            if [[ -z "$changed_files" ]] && [[ -n "${{ github.event.before }}" && "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]]; then
              echo "🔍 Debug: Using git log range method..."
              changed_files=$(git log --name-only --pretty=format: ${{ github.event.before }}..${{ github.event.after }} -- "drawio_files/**/*.drawio" 2>/dev/null | grep -v '^$' | sort -u || true)
              echo "🔍 Debug: Git log range found: '$changed_files'"
            fi
            
            # Method 6: For new repositories or when all else fails, check if this is a new file addition
            if [[ -z "$changed_files" ]]; then
              echo "🔍 Debug: Checking for recently added files..."
              # Get all drawio files and check their git status
              all_drawio_files=$(find drawio_files -name "*.drawio" -type f 2>/dev/null || true)
              echo "🔍 Debug: All drawio files found: '$all_drawio_files'"
              
              # Debug: Check what git log --name-status shows
              echo "🔍 Debug: Git log name-status output:"
              git log -1 --name-status --pretty=format: HEAD 2>/dev/null || echo "Command failed"
              
              for file in $all_drawio_files; do
                echo "🔍 Debug: Checking if $file was added in last commit..."
                # Check if file was added in the last commit
                if git log -1 --name-status --pretty=format: HEAD 2>/dev/null | grep -q "^A[[:space:]]\\+${file}$"; then
                  echo "🔍 Debug: File $file was added in last commit"
                  changed_files="$changed_files $file"
                elif git log -1 --name-status --pretty=format: HEAD 2>/dev/null | grep -q "^M[[:space:]]\\+${file}$"; then
                  echo "🔍 Debug: File $file was modified in last commit"
                  changed_files="$changed_files $file"
                fi
              done
              changed_files=$(echo "$changed_files" | xargs -n1 2>/dev/null | sort -u | tr '\n' ' ' | sed 's/^ *//;s/ *$//' || true)
              echo "🔍 Debug: Found added/modified files: '$changed_files'"
            fi
            
            # Method 7: Last resort - check the actual git diff with the SHAs we have
            if [[ -z "$changed_files" ]] && [[ -n "${{ github.event.before }}" && -n "${{ github.event.after }}" ]]; then
              echo "🔍 Debug: Last resort - detailed SHA diff check..."
              echo "🔍 Debug: Running: git diff --name-only ${{ github.event.before }} ${{ github.event.after }}"
              all_changed=$(git diff --name-only ${{ github.event.before }} ${{ github.event.after }} 2>/dev/null || true)
              echo "🔍 Debug: All changed files in commit: '$all_changed'"
              
              # Filter for drawio files
              changed_files=$(echo "$all_changed" | grep "drawio_files/.*\.drawio$" || true)
              echo "🔍 Debug: Filtered drawio files: '$changed_files'"
            fi
            
            # Additional check: only process files that actually exist
            if [[ -n "$changed_files" ]]; then
              existing_files=""
              for file in $changed_files; do
                if [[ -f "$file" ]]; then
                  existing_files="$existing_files $file"
                fi
              done
              changed_files=$(echo "$existing_files" | xargs -n1 2>/dev/null | sort -u | tr '\n' ' ' | sed 's/^ *//;s/ *$//')
              echo "🔍 Debug: Filtered to existing files: '$changed_files'"
            fi
          fi
          
          # For workflow_dispatch, process all files
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "🔍 Debug: Manual workflow dispatch detected, processing all .drawio files..."
            if [[ -d "drawio_files" ]]; then
              changed_files=$(find drawio_files -name "*.drawio" -type f 2>/dev/null || true)
              echo "🔍 Debug: Found all files for manual dispatch: '$changed_files'"
            fi
          fi
          
          # If png_files folder was recreated, process all drawio files to regenerate PNGs
          if [[ "$folder_was_recreated" == "true" ]]; then
            echo "🔄 PNG folder was recreated - processing all drawio files to regenerate PNGs..."
            if [[ -d "drawio_files" ]]; then
              all_drawio_files=$(find drawio_files -name "*.drawio" -type f 2>/dev/null || true)
              if [[ -n "$all_drawio_files" ]]; then
                changed_files="$all_drawio_files"
                echo "🔍 Debug: Will regenerate all PNG files: '$changed_files'"
              else
                echo "⚠️ No drawio files found to regenerate PNGs from"
              fi
            else
              echo "⚠️ drawio_files directory not found"
            fi
          fi
          
          # Get commit information for changelog (always needed)
          processed_count=0
          failed_count=0
          current_date=$(date +"%d.%m.%Y")
          current_time=$(date +"%H:%M:%S")
          commit_hash=$(git log -1 --format="%h" 2>/dev/null || echo "unknown")
          author_name=$(git log -1 --format="%an" 2>/dev/null || echo "GitHub Action")
          commit_message=$(git log -1 --format="%s" 2>/dev/null || echo "Manual processing")
          
          # If no changed files, still add a changelog entry for the commit
          if [[ -z "$changed_files" ]]; then
            echo "❌ No .drawio files found to process"
            echo "🔍 Debug: Contents of drawio_files directory:"
            ls -la drawio_files/ || echo "Directory doesn't exist"
            echo "🔍 Debug: Event name: ${{ github.event_name }}"
            echo "🔍 Debug: Repository structure:"
            find . -name "*.drawio" -type f 2>/dev/null || echo "No .drawio files found anywhere"
            echo "🔍 Debug: Git status:"
            git status --porcelain || echo "Git status failed"
            echo "🔍 Debug: Recent commits:"
            git log --oneline -5 || echo "Git log failed"
            
            # Still add a changelog entry for this commit
            echo "📝 Adding changelog entry for commit without diagram changes..."
            action="No Diagrams Changed"
            version="N/A"
            diagram_name="System"
            
            changelog_entry="${current_date},${current_time},\"${diagram_name}\",\"${action}\",\"${version}\",\"${commit_hash}\",\"${author_name}\",\"${commit_message}\""
            echo "🔍 Debug: Adding system changelog entry: $changelog_entry"
            echo "$changelog_entry" >> png_files/CHANGELOG.csv
            
            # Verify the entry was added
            if tail -n 1 png_files/CHANGELOG.csv | grep -q "$commit_hash"; then
              echo "✅ System changelog entry added successfully"
            else
              echo "❌ Failed to add system changelog entry"
              echo "🔍 Debug: Last line of changelog: $(tail -n 1 png_files/CHANGELOG.csv)"
            fi
            
            echo "processed=0" >> $GITHUB_OUTPUT
            echo "failed=0" >> $GITHUB_OUTPUT
            
            echo "📄 Changelog contents:"
            tail -3 png_files/CHANGELOG.csv 2>/dev/null || echo "No changelog entries found"
            
            # Don't exit - continue to commit the changelog
            echo "🔍 Debug: Continuing to commit changelog with system entry..."
          else
            echo "📊 Files to process:"
            echo "$changed_files"
            
            echo "🔄 Starting conversion process..."
          fi
          
          # Function to get next version for a diagram
          get_next_version() {
            local diagram_name="$1"
            local commit_msg="$2"
            local last_version=""
            
            # Get the last version for this specific diagram from changelog
            # CSV format: Date,Time,Diagram,Action,Version,Commit,Author,CommitMessage
            # Version is the 5th field
            if [[ -f "png_files/CHANGELOG.csv" ]]; then
              last_version=$(grep "^[^,]*,[^,]*,\"${diagram_name}\"," png_files/CHANGELOG.csv | tail -1 | cut -d',' -f5 | tr -d '"' 2>/dev/null || echo "")
              echo "🔍 Debug: Last version found for $diagram_name: '$last_version'" >&2
            fi
            
            # If no previous version found, this is a new file - start at 1.0
            if [[ -z "$last_version" ]]; then
              echo "🔍 Debug: No previous version found, starting at 1.0" >&2
              echo "1.0"
              return
            fi
            
            # Parse the last version
            if [[ "$last_version" =~ ^([0-9]+)\.([0-9]+)$ ]]; then
              major="${BASH_REMATCH[1]}"
              minor="${BASH_REMATCH[2]}"
              echo "🔍 Debug: Parsed version - Major: $major, Minor: $minor" >&2
              
              # Determine version bump type based on commit message
              commit_lower=$(echo "$commit_msg" | tr '[:upper:]' '[:lower:]')
              echo "🔍 Debug: Commit message (lowercase): '$commit_lower'" >&2
              
              # Check for major release keywords
              if [[ "$commit_lower" =~ (added|major|breaking|release|version) ]]; then
                new_version="$((major + 1)).0"
                echo "🔍 Debug: Major release detected, new version: $new_version" >&2
                echo "$new_version"
              # Check for minor release keywords (default for most updates)
              else
                new_version="${major}.$((minor + 1))"
                echo "🔍 Debug: Minor release detected, new version: $new_version" >&2
                echo "$new_version"
              fi
            else
              # If version parsing fails, default to 1.1
              echo "🔍 Debug: Version parsing failed for '$last_version', defaulting to 1.1" >&2
              echo "1.1"
            fi
          }
          
          # Process each file individually
          for file in $changed_files; do
            [[ -z "$file" ]] && continue
            
            basename=$(basename "$file" .drawio)
            png_file="png_files/${basename}.png"
            
            echo "🔄 Converting: $file -> $png_file"
            
            # Get version for this diagram
            version=$(get_next_version "$basename" "$commit_message")
            echo "📊 Version for $basename: $version"
            
            # Check if source file exists
            if [[ ! -f "$file" ]]; then
              echo "❌ Source file not found: $file"
              action="Failed - Source Not Found"
              ((failed_count++))
            else
              # Convert to PNG with better error handling
              echo "🎨 Running draw.io conversion..."
              
              # Run draw.io conversion and capture output
              conversion_output=""
              if conversion_output=$(xvfb-run --auto-servernum --server-args="-screen 0 1024x768x24" drawio -x -f png -s 2.0 -o "$png_file" "$file" 2>&1); then
                conversion_success="true"
              else
                conversion_success="false"
              fi
              
              echo "🔍 Draw.io output: $conversion_output"
              echo "🔍 Conversion success: $conversion_success"
              
              # Check if conversion was successful by verifying the output file
              if [[ -f "$png_file" && -s "$png_file" ]]; then
                file_size=$(stat -c%s "$png_file" 2>/dev/null || stat -f%z "$png_file" 2>/dev/null || echo "unknown")
                echo "✅ Successfully converted $basename (${file_size} bytes)"
                action="Converted to PNG"
                ((processed_count++))
              else
                echo "❌ PNG conversion failed for: $basename"
                echo "🔍 Debug: PNG file exists: $(test -f "$png_file" && echo "yes" || echo "no")"
                echo "🔍 Debug: PNG file size: $(test -s "$png_file" && echo "non-zero" || echo "zero/missing")"
                action="Failed - Conversion Error"
                ((failed_count++))
              fi
            fi
            
          # Add to changelog with proper version
          changelog_entry="${current_date},${current_time},\"${basename}\",\"${action}\",\"${version}\",\"${commit_hash}\",\"${author_name}\",\"${commit_message}\""
          echo "🔍 Debug: Adding changelog entry: $changelog_entry"
          echo "$changelog_entry" >> png_files/CHANGELOG.csv
          
          # Verify the entry was added
          if tail -n 1 png_files/CHANGELOG.csv | grep -q "$basename"; then
            echo "✅ Changelog entry added successfully"
          else
            echo "❌ Failed to add changelog entry"
            echo "🔍 Debug: Last line of changelog: $(tail -n 1 png_files/CHANGELOG.csv)"
          fi
            
          done
          
          echo "📊 Conversion Summary:"
          echo "✅ Successfully processed: $processed_count files"
          echo "❌ Failed: $failed_count files"
          
          echo "processed=$processed_count" >> $GITHUB_OUTPUT
          echo "failed=$failed_count" >> $GITHUB_OUTPUT
          
          # List generated files
          echo "📁 Generated PNG files:"
          ls -la png_files/*.png 2>/dev/null || echo "No PNG files found"
          
          echo "📄 Changelog contents:"
          tail -5 png_files/CHANGELOG.csv 2>/dev/null || echo "No changelog entries found"
          
          echo "🔍 Debug: Final checks before exit..."
          echo "🔍 Debug: processed_count=$processed_count"
          echo "🔍 Debug: failed_count=$failed_count"
          echo "🔍 Debug: PNG files exist: $(ls png_files/*.png 2>/dev/null | wc -l || echo 0)"
          echo "🔍 Debug: Changelog exists: $(test -f png_files/CHANGELOG.csv && echo "yes" || echo "no")"
          
          # Ensure the script exits successfully
          echo "🔍 Debug: Exiting with success..."
          exit 0

      - name: Commit Changes
        if: always()  # Always run this step to ensure files are committed
        run: |
          echo "🔍 Debug: Preparing to commit changes..."
          echo "🔍 Debug: Processed count: ${{ steps.convert.outputs.processed }}"
          
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          echo "🔍 Debug: Current git status before adding:"
          git status
          
          echo "🔍 Debug: Contents of png_files directory:"
          ls -la png_files/ || echo "png_files directory doesn't exist"
          
          echo "🔍 Debug: Adding png_files to git..."
          git add png_files/
          
          echo "🔍 Debug: Git status after adding:"
          git status
          
          echo "🔍 Debug: Checking if there are staged changes..."
          if git diff --staged --quiet; then
            echo "⚠️ No staged changes detected"
            echo "🔍 Debug: Checking if png_files directory has any files to commit..."
            
            # Check if png_files directory exists and has files
            if [[ -d "png_files" ]] && [[ -n "$(ls -A png_files/)" ]]; then
              echo "📁 png_files directory has content but no staged changes detected"
              echo "🔍 Debug: Force adding png_files directory..."
              git add png_files/ --force
              
              echo "🔍 Debug: Checking staged changes after force add..."
              if git diff --staged --quiet; then
                echo "⚠️ Still no staged changes after force add"
                echo "🔍 Debug: Files in png_files:"
                ls -la png_files/
                echo "🔍 Debug: Git status:"
                git status --porcelain
              else
                echo "✅ Force add successful, committing..."
                echo "🔍 Debug: Files to be committed:"
                git diff --staged --name-only
                
                git commit -m "Create PNG files directory and changelog [skip ci]"
                echo "✅ Committed successfully"
                
                echo "🔍 Debug: Pushing to remote..."
                git push
                echo "✅ Pushed successfully"
              fi
            else
              echo "⚠️ No png_files directory or content to commit"
              echo "🔍 Debug: Directory exists: $(test -d png_files && echo "yes" || echo "no")"
              echo "🔍 Debug: Directory content: $(ls png_files/ 2>/dev/null || echo "empty/missing")"
            fi
          else
            echo "✅ Changes detected, committing..."
            echo "🔍 Debug: Files to be committed:"
            git diff --staged --name-only
            
            git commit -m "Generate PNG files and update changelog [skip ci]"
            echo "✅ Committed successfully"
            
            echo "🔍 Debug: Pushing to remote..."
            git push
            echo "✅ Pushed successfully"
          fi

      - name: Upload to SharePoint
        if: steps.convert.outputs.processed != '0'
        continue-on-error: true
        run: |
          # Get access token
          ACCESS_TOKEN=$(curl -s -X POST \
            "https://login.microsoftonline.com/${{ vars.DIAGRAMS_SHAREPOINT_TENANT_ID }}/oauth2/v2.0/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "client_id=${{ vars.DIAGRAMS_SHAREPOINT_CLIENT_ID }}" \
            -d "client_secret=${{ secrets.DIAGRAMS_SHAREPOINT_CLIENTSECRET }}" \
            -d "scope=https://graph.microsoft.com/.default" \
            -d "grant_type=client_credentials" | \
            jq -r '.access_token')
          
          if [[ "$ACCESS_TOKEN" != "null" && -n "$ACCESS_TOKEN" ]]; then
            # Upload changelog to SharePoint using the configured URL variable
            sharepoint_url="${{ vars.DIAGRAMS_SHAREPOINT_URL }}"
            echo "🔍 Debug: Uploading changelog to SharePoint..."
            echo "🔍 Debug: SharePoint URL from variable: '$sharepoint_url'"
            echo "🔍 Debug: Target path: Diagrams/Diagrams_Changelog.csv"
            
            # Extract site path from the SharePoint URL for Graph API
            # URL format: https://frostaag.sharepoint.com/sites/DatasphereFileConnector
            if [[ "$sharepoint_url" =~ https://([^/]+)/sites/([^/]+) ]]; then
              tenant_domain="${BASH_REMATCH[1]}"
              site_name="${BASH_REMATCH[2]}"
              drive_id="${{ vars.DIAGRAMS_SHAREPOINT_DRIVE_ID }}"
              
              echo "🔍 Debug: Extracted tenant: '$tenant_domain', site: '$site_name'"
              echo "🔍 Debug: Configured Drive ID: '$drive_id'"
              
              # If no drive ID configured, auto-discover the default one
              if [[ -z "$drive_id" ]]; then
                echo "🔍 Debug: No Drive ID configured, auto-discovering default drive..."
                graph_site_url="${tenant_domain}:/sites/${site_name}:"
                
                # Get the default drive ID from the site
                drives_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X GET \
                  "https://graph.microsoft.com/v1.0/sites/${graph_site_url}/drives" \
                  -H "Authorization: Bearer $ACCESS_TOKEN")
                
                drives_http_code=$(echo "$drives_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                drives_response_body=$(echo "$drives_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                
                echo "🔍 Debug: Drives query HTTP Status: $drives_http_code"
                
                if [[ "$drives_http_code" -eq 200 ]]; then
                  # Extract the first drive ID (usually the default document library)
                  drive_id=$(echo "$drives_response_body" | jq -r '.value[0].id' 2>/dev/null || echo "")
                  echo "🔍 Debug: Auto-discovered Drive ID: '$drive_id'"
                  
                  if [[ -z "$drive_id" || "$drive_id" == "null" ]]; then
                    echo "❌ Could not auto-discover drive ID"
                    echo "🔍 Debug: Drives response: $drives_response_body"
                    echo "ℹ️ Please manually set DIAGRAMS_SHAREPOINT_DRIVE_ID variable"
                    exit 1
                  fi
                else
                  echo "❌ Failed to query drives (HTTP $drives_http_code)"
                  echo "🔍 Debug: Response: $drives_response_body"
                  echo "ℹ️ Please manually set DIAGRAMS_SHAREPOINT_DRIVE_ID variable"
                  exit 1
                fi
              fi
              
              echo "🔍 Debug: Using Drive ID: '$drive_id'"
              echo "🔍 Debug: Drive ID length: ${#drive_id}"
              
              # Method 1: Ensure Diagrams folder exists and upload there
              echo "🔍 Debug: Method 1 - Ensuring Diagrams folder exists..."
              graph_site_url="${tenant_domain}:/sites/${site_name}:"
              
              # First, check if Diagrams folder exists
              folder_check=$(curl -s -w "HTTPSTATUS:%{http_code}" -X GET \
                "https://graph.microsoft.com/v1.0/sites/${graph_site_url}/drives/${drive_id}/root:/Diagrams" \
                -H "Authorization: Bearer $ACCESS_TOKEN")
              
              folder_check_code=$(echo "$folder_check" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
              echo "🔍 Debug: Folder check HTTP Status: $folder_check_code"
              
              if [[ "$folder_check_code" -ne 200 ]]; then
                echo "🔍 Debug: Creating Diagrams folder..."
                create_folder=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST \
                  "https://graph.microsoft.com/v1.0/sites/${graph_site_url}/drives/${drive_id}/root/children" \
                  -H "Authorization: Bearer $ACCESS_TOKEN" \
                  -H "Content-Type: application/json" \
                  -d '{"name": "Diagrams", "folder": {}}')
                
                create_folder_code=$(echo "$create_folder" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                create_folder_body=$(echo "$create_folder" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                echo "🔍 Debug: Create folder HTTP Status: $create_folder_code"
                echo "🔍 Debug: Create folder Response: $create_folder_body"
                
                if [[ "$create_folder_code" -ne 200 && "$create_folder_code" -ne 201 ]]; then
                  echo "❌ Failed to create Diagrams folder"
                fi
              else
                echo "🔍 Debug: Diagrams folder already exists"
              fi
              
              # Now try uploading to Diagrams folder (primary method)
              echo "🔍 Debug: Uploading to Diagrams folder..."
              diagrams_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X PUT \
                "https://graph.microsoft.com/v1.0/sites/${graph_site_url}/drives/${drive_id}/root:/Diagrams/Diagrams_Changelog.csv:/content" \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                -H "Content-Type: text/csv" \
                --data-binary @png_files/CHANGELOG.csv)
              
              diagrams_http_code=$(echo "$diagrams_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
              diagrams_response_body=$(echo "$diagrams_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
              
              echo "🔍 Debug: Diagrams folder upload HTTP Status: $diagrams_http_code"
              echo "🔍 Debug: Diagrams folder upload Response: $diagrams_response_body"
              
              if [[ "$diagrams_http_code" -eq 200 || "$diagrams_http_code" -eq 201 ]]; then
                echo "✅ Uploaded changelog to SharePoint Diagrams folder"
              else
                echo "❌ Failed upload to Diagrams folder (HTTP $diagrams_http_code)"
                
                # Method 2: Try direct drive access to Diagrams folder
                echo "🔍 Debug: Method 2 - Trying direct drive access to Diagrams folder..."
                direct_diagrams_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X PUT \
                  "https://graph.microsoft.com/v1.0/drives/${drive_id}/root:/Diagrams/Diagrams_Changelog.csv:/content" \
                  -H "Authorization: Bearer $ACCESS_TOKEN" \
                  -H "Content-Type: text/csv" \
                  --data-binary @png_files/CHANGELOG.csv)
                
                direct_diagrams_http_code=$(echo "$direct_diagrams_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                direct_diagrams_response_body=$(echo "$direct_diagrams_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                
                echo "🔍 Debug: Direct Diagrams HTTP Status: $direct_diagrams_http_code"
                echo "🔍 Debug: Direct Diagrams Response: $direct_diagrams_response_body"
                
                if [[ "$direct_diagrams_http_code" -eq 200 || "$direct_diagrams_http_code" -eq 201 ]]; then
                  echo "✅ Uploaded changelog to SharePoint Diagrams folder (direct access)"
                else
                  echo "❌ Failed direct upload to Diagrams folder (HTTP $direct_diagrams_http_code)"
                  
                  # Method 3: Last resort - upload to root with clear naming
                  echo "🔍 Debug: Method 3 - Last resort upload to root..."
                  root_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X PUT \
                    "https://graph.microsoft.com/v1.0/drives/${drive_id}/root:/Diagrams_Changelog.csv:/content" \
                    -H "Authorization: Bearer $ACCESS_TOKEN" \
                    -H "Content-Type: text/csv" \
                    --data-binary @png_files/CHANGELOG.csv)
                  
                  root_http_code=$(echo "$root_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                  root_response_body=$(echo "$root_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                  
                  echo "🔍 Debug: Root upload HTTP Status: $root_http_code"
                  echo "🔍 Debug: Root upload Response: $root_response_body"
                  
                  if [[ "$root_http_code" -eq 200 || "$root_http_code" -eq 201 ]]; then
                    echo "⚠️ Uploaded changelog to SharePoint root (fallback - please move to Diagrams folder)"
                  else
                    echo "❌ All SharePoint upload methods failed"
                    echo "🔍 Debug: Please verify permissions and configuration"
                  fi
                fi
              fi
            else
              echo "❌ Could not parse SharePoint URL: '$sharepoint_url'"
              echo "❌ Expected format: https://tenant.sharepoint.com/sites/sitename"
            fi
          else
            echo "❌ Failed to get SharePoint access token"
            echo "🔍 Debug: ACCESS_TOKEN length: ${#ACCESS_TOKEN}"
            echo "🔍 Debug: ACCESS_TOKEN starts with: $(echo "$ACCESS_TOKEN" | head -c 20)..."
          fi

      - name: Upload PNG files to SAP BTP Document Management
        if: steps.convert.outputs.processed != '0'
        continue-on-error: true
        run: |
          echo "🔍 Starting SAP BTP Document Management upload..."
          
          # Check if SAP BTP variables are configured
          sap_token_url="${{ vars.DIAGRAMS_SAP_BTP_TOKEN_URL }}"
          sap_client_id="${{ vars.DIAGRAMS_SAP_BTP_CLIENT_ID }}"
          sap_dm_base_url="${{ vars.DIAGRAMS_SAP_BTP_DM_BASE_URL }}"
          sap_repository_id="${{ vars.DIAGRAMS_SAP_BTP_REPOSITORY_ID }}"
          
          echo "🔍 Debug: SAP BTP Token URL configured: $(if [[ -n "$sap_token_url" ]]; then echo "Yes"; else echo "No"; fi)"
          echo "🔍 Debug: SAP BTP Client ID configured: $(if [[ -n "$sap_client_id" ]]; then echo "Yes"; else echo "No"; fi)"
          echo "🔍 Debug: SAP BTP DM Base URL configured: $(if [[ -n "$sap_dm_base_url" ]]; then echo "Yes"; else echo "No"; fi)"
          echo "🔍 Debug: SAP BTP Repository ID configured: $(if [[ -n "$sap_repository_id" ]]; then echo "Yes"; else echo "No"; fi)"
          
          if [[ -n "$sap_token_url" && -n "$sap_client_id" && -n "$sap_dm_base_url" ]]; then
            echo "📤 Getting SAP BTP access token..."
            
            # Get access token for SAP BTP Document Management
            sap_token_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST "$sap_token_url" \
              -H "Content-Type: application/x-www-form-urlencoded" \
              -d "grant_type=client_credentials" \
              -d "client_id=$sap_client_id" \
              -d "client_secret=${{ secrets.DIAGRAMS_SAP_BTP_CLIENT_SECRET }}")
            
            sap_token_http_code=$(echo "$sap_token_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
            sap_token_response_body=$(echo "$sap_token_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
            
            echo "🔍 Debug: SAP BTP token HTTP Status: $sap_token_http_code"
            
            if [[ "$sap_token_http_code" -eq 200 ]]; then
              sap_access_token=$(echo "$sap_token_response_body" | jq -r '.access_token' 2>/dev/null || echo "")
              
              if [[ -n "$sap_access_token" && "$sap_access_token" != "null" ]]; then
                echo "✅ SAP BTP access token obtained successfully"
                echo "🔍 Debug: Token length: ${#sap_access_token}"
                
                # Ensure Diagrams folder exists in SAP DM (check and create on every run)
                diagrams_folder_id=""
                
                echo "📁 Ensuring Diagrams folder exists in SAP Document Management..."
                
                # Always check for existing Diagrams folder first
                echo "🔍 Debug: Searching for existing Diagrams folder..."
                folders_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X GET \
                  "${sap_dm_base_url}/browser/objects/root/children?filter=objectType%20eq%20'folder'%20and%20name%20eq%20'Diagrams'" \
                  -H "Authorization: Bearer $sap_access_token" \
                  -H "Accept: application/json")
                
                folders_http_code=$(echo "$folders_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                folders_response_body=$(echo "$folders_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                
                echo "🔍 Debug: Folders search HTTP Status: $folders_http_code"
                
                if [[ "$folders_http_code" -eq 200 ]]; then
                  # Check if Diagrams folder exists
                  folder_count=$(echo "$folders_response_body" | jq -r '.objects | length' 2>/dev/null || echo "0")
                  
                  if [[ "$folder_count" -gt 0 ]]; then
                    diagrams_folder_id=$(echo "$folders_response_body" | jq -r '.objects[0].id' 2>/dev/null || echo "")
                    echo "✅ Found existing Diagrams folder: $diagrams_folder_id"
                  fi
                fi
                
                # If folder doesn't exist or couldn't be found, create it
                if [[ -z "$diagrams_folder_id" || "$diagrams_folder_id" == "null" ]]; then
                  echo "📁 Creating Diagrams folder in SAP Document Management..."
                  
                  create_folder_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST \
                    "${sap_dm_base_url}/browser/objects/root/children" \
                    -H "Authorization: Bearer $sap_access_token" \
                    -H "Content-Type: application/json" \
                    -H "Accept: application/json" \
                    -d '{
                      "name": "Diagrams",
                      "description": "Automatically generated diagram files from GitHub workflow",
                      "objectType": "folder"
                    }')
                  
                  create_folder_http_code=$(echo "$create_folder_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                  create_folder_response_body=$(echo "$create_folder_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                  
                  echo "🔍 Debug: Create folder HTTP Status: $create_folder_http_code"
                  
                  if [[ "$create_folder_http_code" -eq 201 ]]; then
                    diagrams_folder_id=$(echo "$create_folder_response_body" | jq -r '.id' 2>/dev/null || echo "")
                    echo "✅ Successfully created Diagrams folder: $diagrams_folder_id"
                  elif [[ "$create_folder_http_code" -eq 409 ]]; then
                    # Folder already exists (conflict), try to find it again
                    echo "📁 Diagrams folder already exists (HTTP 409), searching again..."
                    retry_folders_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X GET \
                      "${sap_dm_base_url}/browser/objects/root/children?filter=objectType%20eq%20'folder'%20and%20name%20eq%20'Diagrams'" \
                      -H "Authorization: Bearer $sap_access_token" \
                      -H "Accept: application/json")
                    
                    retry_folders_http_code=$(echo "$retry_folders_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                    retry_folders_response_body=$(echo "$retry_folders_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                    
                    if [[ "$retry_folders_http_code" -eq 200 ]]; then
                      retry_folder_count=$(echo "$retry_folders_response_body" | jq -r '.objects | length' 2>/dev/null || echo "0")
                      if [[ "$retry_folder_count" -gt 0 ]]; then
                        diagrams_folder_id=$(echo "$retry_folders_response_body" | jq -r '.objects[0].id' 2>/dev/null || echo "")
                        echo "✅ Found Diagrams folder after conflict: $diagrams_folder_id"
                      fi
                    fi
                  else
                    echo "❌ Failed to create Diagrams folder (HTTP $create_folder_http_code)"
                    echo "🔍 Debug: Response: $create_folder_response_body"
                  fi
                fi
                
                # Final fallback: use root if we still don't have a folder ID
                if [[ -z "$diagrams_folder_id" || "$diagrams_folder_id" == "null" ]]; then
                  echo "⚠️ Could not create or find Diagrams folder, using root as fallback"
                  diagrams_folder_id="root"
                else
                  echo "📁 Using Diagrams folder for uploads: $diagrams_folder_id"
                fi
                
                # Upload PNG files to SAP Document Management
                upload_count=0
                failed_upload_count=0
                
                for png_file in png_files/*.png; do
                  if [[ -f "$png_file" ]]; then
                    filename=$(basename "$png_file")
                    echo "📤 Uploading $filename to SAP Document Management..."
                    
                    # Get file metadata for upload
                    file_size=$(stat -c%s "$png_file" 2>/dev/null || stat -f%z "$png_file" 2>/dev/null || echo "0")
                    
                    # First, create the document object
                    create_doc_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST \
                      "${sap_dm_base_url}/browser/objects/${diagrams_folder_id}/children" \
                      -H "Authorization: Bearer $sap_access_token" \
                      -H "Content-Type: application/json" \
                      -H "Accept: application/json" \
                      -d "{
                        \"name\": \"$filename\",
                        \"description\": \"Automatically generated diagram from GitHub workflow\",
                        \"objectType\": \"document\",
                        \"contentType\": \"image/png\"
                      }")
                    
                    create_doc_http_code=$(echo "$create_doc_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                    create_doc_response_body=$(echo "$create_doc_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                    
                    echo "🔍 Debug: Create document HTTP Status: $create_doc_http_code"
                    
                    if [[ "$create_doc_http_code" -eq 201 ]]; then
                      document_id=$(echo "$create_doc_response_body" | jq -r '.id' 2>/dev/null || echo "")
                      
                      if [[ -n "$document_id" && "$document_id" != "null" ]]; then
                        echo "📄 Created document object: $document_id"
                        
                        # Upload the actual file content
                        upload_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X PUT \
                          "${sap_dm_base_url}/browser/objects/${document_id}/content" \
                          -H "Authorization: Bearer $sap_access_token" \
                          -H "Content-Type: image/png" \
                          --data-binary @"$png_file")
                        
                        upload_http_code=$(echo "$upload_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                        upload_response_body=$(echo "$upload_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                        
                        echo "🔍 Debug: File upload HTTP Status: $upload_http_code"
                        
                        if [[ "$upload_http_code" -eq 200 || "$upload_http_code" -eq 201 ]]; then
                          echo "✅ Successfully uploaded $filename to SAP Document Management"
                          ((upload_count++))
                        else
                          echo "❌ Failed to upload file content for $filename (HTTP $upload_http_code)"
                          echo "🔍 Debug: Upload response: $upload_response_body"
                          ((failed_upload_count++))
                        fi
                      else
                        echo "❌ Could not extract document ID from response"
                        ((failed_upload_count++))
                      fi
                    else
                      echo "❌ Failed to create document object for $filename (HTTP $create_doc_http_code)"
                      echo "🔍 Debug: Create doc response: $create_doc_response_body"
                      ((failed_upload_count++))
                    fi
                  fi
                done
                
                echo "📊 SAP BTP Upload Summary:"
                echo "✅ Successfully uploaded: $upload_count files"
                echo "❌ Failed uploads: $failed_upload_count files"
                
              else
                echo "❌ Could not extract access token from SAP BTP response"
                echo "🔍 Debug: Token response: $sap_token_response_body"
              fi
            else
              echo "❌ Failed to get SAP BTP access token (HTTP $sap_token_http_code)"
              echo "🔍 Debug: Token response: $sap_token_response_body"
            fi
          else
            echo "⚠️ SAP BTP Document Management not configured"
            echo "ℹ️ To enable SAP BTP uploads, set these organization variables:"
            echo "   - DIAGRAMS_SAP_BTP_TOKEN_URL (OAuth2 token endpoint)"
            echo "   - DIAGRAMS_SAP_BTP_CLIENT_ID (OAuth2 client ID)"
            echo "   - DIAGRAMS_SAP_BTP_DM_BASE_URL (Document Management API base URL)"
            echo "   - DIAGRAMS_SAP_BTP_REPOSITORY_ID (Optional: specific repository ID)"
            echo "   And this secret:"
            echo "   - DIAGRAMS_SAP_BTP_CLIENT_SECRET (OAuth2 client secret)"
          fi

  notify:
    needs: process
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Checkout for Teams Notification
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
          
      - name: Send Teams Notification
        continue-on-error: true
        run: |
          echo "🔔 Preparing Teams notification..."
          
          if [[ "${{ needs.process.result }}" == "success" ]]; then
            status="✅ Success"
            color="28a745"
          else
            status="❌ Failed"
            color="dc3545"
          fi
          
          processed="${{ needs.process.outputs.processed || '0' }}"
          failed="${{ needs.process.outputs.failed || '0' }}"
          
          # Get git information
          commit_hash=$(git log -1 --format="%h" 2>/dev/null || echo "unknown")
          commit_full_hash=$(git log -1 --format="%H" 2>/dev/null || echo "unknown")
          commit_message=$(git log -1 --format="%s" 2>/dev/null || echo "Manual processing")
          
          # Get author with fallback: display name -> email -> github actor
          author_display_name=$(git log -1 --format="%an" 2>/dev/null || echo "")
          author_email=$(git log -1 --format="%ae" 2>/dev/null || echo "")
          
          # Use display name, fallback to email if display name is empty or generic
          if [[ -z "$author_display_name" || "$author_display_name" == "GitHub" || "$author_display_name" == "github-actions" ]]; then
            if [[ -n "$author_email" && "$author_email" != "noreply@github.com" ]]; then
              author_info="$author_email"
            else
              author_info="${{ github.actor }}"
            fi
          else
            author_info="$author_display_name"
          fi
          
          # Get processed diagram name (single diagram per commit)
          diagram_name=""
          diagram_display_name=""
          if [[ -f "png_files/CHANGELOG.csv" ]]; then
            # Get the most recent diagram from changelog
            diagram_name=$(tail -n 1 png_files/CHANGELOG.csv | cut -d',' -f3 | tr -d '"' 2>/dev/null || echo "")
          fi
          
          if [[ -z "$diagram_name" || "$diagram_name" == "Diagram" || "$diagram_name" == "System" ]]; then
            diagram_display_name="No specific diagram"
          else
            # Parse the diagram name to extract readable parts
            # Expected format: x.y.description (e.g., "1.2.Azure Cloud Architecture")
            if [[ "$diagram_name" =~ ^([0-9]+)\.([0-9]+)\.(.+)$ ]]; then
              tech_id="${BASH_REMATCH[1]}"
              detail_level="${BASH_REMATCH[2]}"
              description="${BASH_REMATCH[3]}"
              
              # Map technology IDs to readable names
              case "$tech_id" in
                0) tech_name="Multi-tech" ;;
                1) tech_name="Cloud" ;;
                2) tech_name="Network" ;;
                3) tech_name="SAP" ;;
                *) tech_name="Tech-$tech_id" ;;
              esac
              
              # Map detail levels to readable names
              case "$detail_level" in
                1) detail_name="High-level" ;;
                2) detail_name="Intermediate" ;;
                3) detail_name="Detailed" ;;
                *) detail_name="Level-$detail_level" ;;
              esac
              
              diagram_display_name="📊 $description ($tech_name, $detail_name)"
            else
              diagram_display_name="📊 $diagram_name"
            fi
          fi
          
          echo "🔍 Debug: commit_hash=$commit_hash"
          echo "🔍 Debug: author_display_name=$author_display_name"
          echo "🔍 Debug: author_email=$author_email"
          echo "🔍 Debug: author_info=$author_info"
          echo "🔍 Debug: commit_message=$commit_message"
          echo "🔍 Debug: diagram_name=$diagram_name"
          
          # Check if Teams webhook is configured using organization variable
          teams_webhook="${{ vars.DIAGRAMS_TEAMS_NOTIFICATION_WEBHOOK }}"
          
          echo "🔍 Teams webhook configured: $(if [[ -n "$teams_webhook" ]]; then echo "Yes (${#teams_webhook} chars)"; else echo "No"; fi)"
          echo "🔍 Using organization variable: DIAGRAMS_TEAMS_NOTIFICATION_WEBHOOK"
          echo "🔍 Variable status: $(if [[ -n "${{ vars.DIAGRAMS_TEAMS_NOTIFICATION_WEBHOOK }}" ]]; then echo "Set"; else echo "Not set"; fi)"
          
          if [[ -n "$teams_webhook" ]]; then
            echo "📤 Sending Teams notification..."
            echo "🔍 Teams webhook URL starts with: $(echo "$teams_webhook" | head -c 50)..."
            
            # Create JSON payload with proper escaping
            echo "🔍 Sending payload to Teams..."
            
            # Simplified title
            simple_title="📊 Draw.io Processing Complete"
            
            # Build summary text
            if [[ "$processed" != "0" && "$failed" == "0" ]]; then
              summary_text="Successfully processed $processed diagram(s)"
            elif [[ "$processed" != "0" && "$failed" != "0" ]]; then
              summary_text="Processed $processed, failed $failed diagram(s)"
            elif [[ "$processed" == "0" && "$failed" != "0" ]]; then
              summary_text="Failed to process $failed diagram(s)"
            else
              summary_text="No diagrams found to process"
            fi
            
            # Escape commit message and diagram name for JSON
            escaped_commit_message=$(echo "$commit_message" | sed 's/"/\\"/g' | sed "s/'/\\'/g")
            escaped_diagram_display_name=$(echo "$diagram_display_name" | sed 's/"/\\"/g')
            escaped_author_info=$(echo "$author_info" | sed 's/"/\\"/g')
            
            response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST "$teams_webhook" \
              -H "Content-Type: application/json" \
              -d "{
                \"@type\": \"MessageCard\",
                \"@context\": \"https://schema.org/extensions\",
                \"summary\": \"$simple_title\",
                \"themeColor\": \"$color\",
                \"title\": \"$simple_title\",
                \"text\": \"**Status:** $status - $summary_text\",
                \"sections\": [{
                  \"activityTitle\": \"📋 Processing Details\",
                  \"facts\": [
                    {\"name\": \"👤 Author\", \"value\": \"$escaped_author_info\"},
                    {\"name\": \"📝 Commit\", \"value\": \"$commit_hash\"},
                    {\"name\": \"💬 Message\", \"value\": \"$escaped_commit_message\"},
                    {\"name\": \"📊 Diagram\", \"value\": \"$escaped_diagram_display_name\"},
                    {\"name\": \"✅ Processed\", \"value\": \"$processed\"},
                    {\"name\": \"❌ Failed\", \"value\": \"$failed\"},
                    {\"name\": \"🔄 Run\", \"value\": \"#${{ github.run_number }}\"}
                  ]
                }],
                \"potentialAction\": [{
                  \"@type\": \"OpenUri\",
                  \"name\": \"🔍 View Details\",
                  \"targets\": [{
                    \"os\": \"default\",
                    \"uri\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
                  }]
                }, {
                  \"@type\": \"OpenUri\",
                  \"name\": \"📁 View Commit\",
                  \"targets\": [{
                    \"os\": \"default\",
                    \"uri\": \"${{ github.server_url }}/${{ github.repository }}/commit/$commit_full_hash\"
                  }]
                }]
              }")
            
            http_code=$(echo "$response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
            response_body=$(echo "$response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
            
            echo "🔍 HTTP Status: $http_code"
            echo "🔍 Response: $response_body"
            
            if [[ "$http_code" -eq 200 ]]; then
              echo "✅ Teams notification sent successfully"
            elif [[ "$http_code" -eq 202 ]]; then
              echo "✅ Teams notification accepted (HTTP 202)"
            else
              echo "❌ Failed to send Teams notification (HTTP $http_code)"
              echo "🔍 Full response: $response"
              
              # Try simplified payload as fallback
              echo "🔍 Trying simplified Teams payload..."
              simple_payload="{\"text\":\"📊 Draw.io Processing $status - $processed files processed, $failed failed (Run #${{ github.run_number }})\"}"
              
              simple_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST "$teams_webhook" \
                -H "Content-Type: application/json" \
                -d "$simple_payload")
              
              simple_http_code=$(echo "$simple_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
              simple_response_body=$(echo "$simple_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
              
              echo "🔍 Simple payload HTTP Status: $simple_http_code"
              echo "🔍 Simple payload Response: $simple_response_body"
              
              if [[ "$simple_http_code" -eq 200 || "$simple_http_code" -eq 202 ]]; then
                echo "✅ Teams notification sent successfully (simple format)"
              else
                echo "❌ Both Teams notification attempts failed"
              fi
            fi
          else
            echo "⚠️ Teams webhook not configured"
            echo "ℹ️ To enable Teams notifications:"
            echo "   Set organization variable: DIAGRAMS_TEAMS_NOTIFICATION_WEBHOOK"
            echo "   This should contain your Teams webhook URL (no authentication required)"
          fi
          
          echo "📊 Final Summary:"
          echo "- Status: $status"
          echo "- Files processed: $processed"
          echo "- Files failed: $failed"
          echo "- Workflow run: #${{ github.run_number }}"
