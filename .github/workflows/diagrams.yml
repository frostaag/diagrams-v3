name: Draw.io to PNG Processing V3

on:
  push:
    paths:
      - 'drawio_files/**/*.drawio'
      - 'drawio_files/**'  # Also trigger on folder changes
  workflow_dispatch:

env:
  DRAWIO_VERSION: "26.2.2"

permissions:
  contents: write

jobs:
  process:
    runs-on: ubuntu-latest
    outputs:
      processed: ${{ steps.convert.outputs.processed }}
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Draw.io
        run: |
          sudo apt-get update
          sudo apt-get install -y wget xvfb
          wget -q "https://github.com/jgraph/drawio-desktop/releases/download/v${{ env.DRAWIO_VERSION }}/drawio-amd64-${{ env.DRAWIO_VERSION }}.deb"
          sudo apt-get install -y "./drawio-amd64-${{ env.DRAWIO_VERSION }}.deb"

      - name: Convert & Update Changelog
        id: convert
        shell: bash
        run: |
          set +e  # Disable exit on error for the entire script
          echo "üîç Debug: Starting conversion process..."
          
          # FORCE creation of directories and files - always ensure they exist
          echo "üìÅ Force ensuring png_files directory exists..."
          mkdir -p png_files
          echo "üìÅ Directory created/verified: png_files"
          
          # Force create/verify changelog file with proper header (preserve existing entries)
          echo "üìÑ Force ensuring changelog file exists with proper header..."
          if [[ ! -f "png_files/CHANGELOG.csv" ]]; then
            echo "Date,Time,Diagram,Action,Version,Commit,Author,CommitMessage" > png_files/CHANGELOG.csv
            echo "üìÑ Changelog file created with header"
          else
            echo "üìÑ Changelog file already exists, preserving existing entries"
            # Verify it has the correct header
            if ! head -n 1 png_files/CHANGELOG.csv | grep -q "Date,Time,Diagram,Action,Version,Commit,Author,CommitMessage"; then
              echo "üìÑ Fixing changelog header..."
              # Create temp file with proper header and existing content
              echo "Date,Time,Diagram,Action,Version,Commit,Author,CommitMessage" > png_files/CHANGELOG_temp.csv
              tail -n +2 png_files/CHANGELOG.csv >> png_files/CHANGELOG_temp.csv 2>/dev/null || true
              mv png_files/CHANGELOG_temp.csv png_files/CHANGELOG.csv
              echo "üìÑ Changelog header fixed"
            fi
          fi
          
          # Verify the files were actually created
          if [[ -d "png_files" ]]; then
            echo "‚úÖ png_files directory confirmed to exist"
          else
            echo "‚ùå CRITICAL: png_files directory still missing after creation!"
          fi
          
          if [[ -f "png_files/CHANGELOG.csv" ]]; then
            echo "‚úÖ CHANGELOG.csv confirmed to exist"
            echo "ÔøΩ Changelog header: $(head -n 1 png_files/CHANGELOG.csv)"
          else
            echo "‚ùå CRITICAL: CHANGELOG.csv missing after creation!"
          fi
          
          echo "üîç Debug: Checking for draw.io files..."
          
          # Check if png_files folder was recreated (empty or missing PNG files)
          png_count=$(ls png_files/*.png 2>/dev/null | wc -l || echo 0)
          drawio_count=$(find drawio_files -name "*.drawio" -type f 2>/dev/null | wc -l || echo 0)
          
          echo "üîç Debug: Found $png_count PNG files and $drawio_count drawio files"
          
          # If png_files folder was deleted/recreated, we need to regenerate all PNGs
          folder_was_recreated=false
          if [[ $png_count -eq 0 && $drawio_count -gt 0 ]]; then
            echo "üìÑ PNG files missing but drawio files exist - folder was likely deleted"
            echo "üîÑ Will regenerate all PNG files from existing drawio files"
            folder_was_recreated=true
          fi
          
          # Get changed draw.io files - improved logic for only changed files
          changed_files=""
          
          # For push events, only process files that were actually changed in this commit
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "üîç Debug: Push event detected, checking for changed files in this push..."
            echo "üîç Debug: Event before SHA: '${{ github.event.before }}'"
            echo "üîç Debug: Event after SHA: '${{ github.event.after }}'"
            
            # Try multiple methods to get changed files
            # Method 1: Use GitHub event before/after SHAs
            if [[ -n "${{ github.event.before }}" && -n "${{ github.event.after }}" && "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]]; then
              echo "üîç Debug: Using GitHub event SHAs..."
              changed_files=$(git diff --name-only ${{ github.event.before }}..${{ github.event.after }} -- "drawio_files/**/*.drawio" 2>/dev/null || true)
              echo "üîç Debug: GitHub event diff found: '$changed_files'"
            fi
            
            # Method 2: Fallback to HEAD^ comparison
            if [[ -z "$changed_files" ]] && git rev-parse --verify HEAD^ >/dev/null 2>&1; then
              echo "üîç Debug: Fallback - checking git diff HEAD^..HEAD..."
              changed_files=$(git diff --name-only HEAD^..HEAD -- "drawio_files/**/*.drawio" 2>/dev/null || true)
              echo "üîç Debug: HEAD diff found: '$changed_files'"
            fi
            
            # Method 3: Use git log to find files changed in last commit
            if [[ -z "$changed_files" ]]; then
              echo "üîç Debug: Using git log method..."
              changed_files=$(git log -1 --name-only --pretty=format: -- "drawio_files/**/*.drawio" 2>/dev/null | grep -v '^$' || true)
              echo "üîç Debug: Git log found: '$changed_files'"
            fi
            
            # Method 4: Use git show to get files from current commit
            if [[ -z "$changed_files" ]]; then
              echo "üîç Debug: Using git show method..."
              changed_files=$(git show --name-only --pretty=format: HEAD -- "drawio_files/**/*.drawio" 2>/dev/null | grep -v '^$' || true)
              echo "üîç Debug: Git show found: '$changed_files'"
            fi
            
            # Method 5: Check for files modified in the push using git log with range
            if [[ -z "$changed_files" ]] && [[ -n "${{ github.event.before }}" && "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]]; then
              echo "üîç Debug: Using git log range method..."
              changed_files=$(git log --name-only --pretty=format: ${{ github.event.before }}..${{ github.event.after }} -- "drawio_files/**/*.drawio" 2>/dev/null | grep -v '^$' | sort -u || true)
              echo "üîç Debug: Git log range found: '$changed_files'"
            fi
            
            # Method 6: For new repositories or when all else fails, check if this is a new file addition
            if [[ -z "$changed_files" ]]; then
              echo "üîç Debug: Checking for recently added files..."
              # Get all drawio files and check their git status
              all_drawio_files=$(find drawio_files -name "*.drawio" -type f 2>/dev/null || true)
              echo "üîç Debug: All drawio files found: '$all_drawio_files'"
              
              # Debug: Check what git log --name-status shows
              echo "üîç Debug: Git log name-status output:"
              git log -1 --name-status --pretty=format: HEAD 2>/dev/null || echo "Command failed"
              
              for file in $all_drawio_files; do
                echo "üîç Debug: Checking if $file was added in last commit..."
                # Check if file was added in the last commit
                if git log -1 --name-status --pretty=format: HEAD 2>/dev/null | grep -q "^A[[:space:]]\\+${file}$"; then
                  echo "üîç Debug: File $file was added in last commit"
                  changed_files="$changed_files $file"
                elif git log -1 --name-status --pretty=format: HEAD 2>/dev/null | grep -q "^M[[:space:]]\\+${file}$"; then
                  echo "üîç Debug: File $file was modified in last commit"
                  changed_files="$changed_files $file"
                fi
              done
              changed_files=$(echo "$changed_files" | xargs -n1 2>/dev/null | sort -u | tr '\n' ' ' | sed 's/^ *//;s/ *$//' || true)
              echo "üîç Debug: Found added/modified files: '$changed_files'"
            fi
            
            # Method 7: Last resort - check the actual git diff with the SHAs we have
            if [[ -z "$changed_files" ]] && [[ -n "${{ github.event.before }}" && -n "${{ github.event.after }}" ]]; then
              echo "üîç Debug: Last resort - detailed SHA diff check..."
              echo "üîç Debug: Running: git diff --name-only ${{ github.event.before }} ${{ github.event.after }}"
              all_changed=$(git diff --name-only ${{ github.event.before }} ${{ github.event.after }} 2>/dev/null || true)
              echo "üîç Debug: All changed files in commit: '$all_changed'"
              
              # Filter for drawio files
              changed_files=$(echo "$all_changed" | grep "drawio_files/.*\.drawio$" || true)
              echo "üîç Debug: Filtered drawio files: '$changed_files'"
            fi
            
            # Additional check: only process files that actually exist
            if [[ -n "$changed_files" ]]; then
              existing_files=""
              while IFS= read -r file; do
                if [[ -f "$file" ]]; then
                  existing_files="$existing_files"$'\n'"$file"
                fi
              done <<< "$changed_files"
              changed_files=$(echo "$existing_files" | grep -v '^$' | sort -u | tr '\n' ' ' | sed 's/^ *//;s/ *$//')
              echo "üîç Debug: Filtered to existing files: '$changed_files'"
            fi
          fi
          
          # For workflow_dispatch, process all files
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "üîç Debug: Manual workflow dispatch detected, processing all .drawio files..."
            if [[ -d "drawio_files" ]]; then
              changed_files=$(find drawio_files -name "*.drawio" -type f 2>/dev/null || true)
              echo "üîç Debug: Found all files for manual dispatch: '$changed_files'"
            fi
          fi
          
          # If png_files folder was recreated, process all drawio files to regenerate PNGs
          if [[ "$folder_was_recreated" == "true" ]]; then
            echo "üîÑ PNG folder was recreated - processing all drawio files to regenerate PNGs..."
            if [[ -d "drawio_files" ]]; then
              all_drawio_files=$(find drawio_files -name "*.drawio" -type f 2>/dev/null || true)
              if [[ -n "$all_drawio_files" ]]; then
                changed_files="$all_drawio_files"
                echo "üîç Debug: Will regenerate all PNG files: '$changed_files'"
              else
                echo "‚ö†Ô∏è No drawio files found to regenerate PNGs from"
              fi
            else
              echo "‚ö†Ô∏è drawio_files directory not found"
            fi
          fi
          
          # Get commit information for changelog (always needed)
          processed_count=0
          failed_count=0
          current_date=$(date +"%d.%m.%Y")
          current_time=$(date +"%H:%M:%S")
          commit_hash=$(git log -1 --format="%h" 2>/dev/null || echo "unknown")
          author_name=$(git log -1 --format="%an" 2>/dev/null || echo "GitHub Action")
          commit_message=$(git log -1 --format="%s" 2>/dev/null || echo "Manual processing")
          
          # If no changed files, still add a changelog entry for the commit
          if [[ -z "$changed_files" ]]; then
            echo "‚ùå No .drawio files found to process"
            echo "üîç Debug: Contents of drawio_files directory:"
            ls -la drawio_files/ || echo "Directory doesn't exist"
            echo "üîç Debug: Event name: ${{ github.event_name }}"
            echo "üîç Debug: Repository structure:"
            find . -name "*.drawio" -type f 2>/dev/null || echo "No .drawio files found anywhere"
            echo "üîç Debug: Git status:"
            git status --porcelain || echo "Git status failed"
            echo "üîç Debug: Recent commits:"
            git log --oneline -5 || echo "Git log failed"
            
            # Still add a changelog entry for this commit
            echo "üìù Adding changelog entry for commit without diagram changes..."
            action="No Diagrams Changed"
            version="N/A"
            diagram_name="System"
            
            changelog_entry="${current_date},${current_time},\"${diagram_name}\",\"${action}\",\"${version}\",\"${commit_hash}\",\"${author_name}\",\"${commit_message}\""
            echo "üîç Debug: Adding system changelog entry: $changelog_entry"
            echo "$changelog_entry" >> png_files/CHANGELOG.csv
            
            # Verify the entry was added
            if tail -n 1 png_files/CHANGELOG.csv | grep -q "$commit_hash"; then
              echo "‚úÖ System changelog entry added successfully"
            else
              echo "‚ùå Failed to add system changelog entry"
              echo "üîç Debug: Last line of changelog: $(tail -n 1 png_files/CHANGELOG.csv)"
            fi
            
            echo "processed=0" >> $GITHUB_OUTPUT
            echo "failed=0" >> $GITHUB_OUTPUT
            
            echo "üìÑ Changelog contents:"
            tail -3 png_files/CHANGELOG.csv 2>/dev/null || echo "No changelog entries found"
            
            # Don't exit - continue to commit the changelog
            echo "üîç Debug: Continuing to commit changelog with system entry..."
          else
            echo "üìä Files to process:"
            echo "$changed_files"
            
            echo "üîÑ Starting conversion process..."
          fi
          
          # Function to get next version for a diagram
          get_next_version() {
            local diagram_name="$1"
            local commit_msg="$2"
            local last_version=""
            
            # Get the last version for this specific diagram from changelog
            # CSV format: Date,Time,Diagram,Action,Version,Commit,Author,CommitMessage
            # Version is the 5th field
            if [[ -f "png_files/CHANGELOG.csv" ]]; then
              # Debug: Show what we're searching for
              echo "üîç Debug: Searching for diagram '$diagram_name' in changelog..." >&2
              echo "üîç Debug: Changelog entries for this diagram:" >&2
              grep "^[^,]*,[^,]*,\"${diagram_name}\"," png_files/CHANGELOG.csv >&2 || echo "No entries found" >&2
              
              # Extract the last version for this specific diagram
              last_version=$(grep "^[^,]*,[^,]*,\"${diagram_name}\"," png_files/CHANGELOG.csv | tail -1 | cut -d',' -f5 | tr -d '"' 2>/dev/null || echo "")
              echo "üîç Debug: Last version found for $diagram_name: '$last_version'" >&2
              
              # Also try without quotes in case format varies
              if [[ -z "$last_version" ]]; then
                last_version=$(grep "^[^,]*,[^,]*,${diagram_name}," png_files/CHANGELOG.csv | tail -1 | cut -d',' -f5 | tr -d '"' 2>/dev/null || echo "")
                echo "üîç Debug: Last version found (no quotes) for $diagram_name: '$last_version'" >&2
              fi
            else
              echo "üîç Debug: No changelog file found" >&2
            fi
            
            # If no previous version found, this is a new file - start at 1.0
            if [[ -z "$last_version" || "$last_version" == "N/A" ]]; then
              echo "üîç Debug: No previous version found, starting at 1.0" >&2
              echo "1.0"
              return
            fi
            
            # Parse the last version
            if [[ "$last_version" =~ ^([0-9]+)\.([0-9]+)$ ]]; then
              major="${BASH_REMATCH[1]}"
              minor="${BASH_REMATCH[2]}"
              echo "üîç Debug: Parsed version - Major: $major, Minor: $minor" >&2
              
              # Determine version bump type based on commit message
              commit_lower=$(echo "$commit_msg" | tr '[:upper:]' '[:lower:]')
              echo "üîç Debug: Commit message (lowercase): '$commit_lower'" >&2
              
              # Check for major release keywords
              if [[ "$commit_lower" =~ (added|major|breaking|release|version) ]]; then
                new_version="$((major + 1)).0"
                echo "üîç Debug: Major release detected, new version: $new_version" >&2
                echo "$new_version"
              # Check for minor release keywords (default for most updates)
              else
                new_version="${major}.$((minor + 1))"
                echo "üîç Debug: Minor release detected, new version: $new_version" >&2
                echo "$new_version"
              fi
            else
              # If version parsing fails, default to 1.1
              echo "üîç Debug: Version parsing failed for '$last_version', defaulting to 1.1" >&2
              echo "1.1"
            fi
          }
          
          # Process each file individually - handle filenames with spaces
          # Convert changed_files to array to properly handle spaces
          if [[ -n "$changed_files" ]]; then
            # Use while loop with proper IFS handling for filenames with spaces
            while IFS= read -r file; do
              [[ -z "$file" ]] && continue
              
              basename=$(basename "$file" .drawio)
              png_file="png_files/${basename}.png"
            
            echo "üîÑ Converting: $file -> $png_file"
            
            # Get version for this diagram
            version=$(get_next_version "$basename" "$commit_message")
            echo "üìä Version for $basename: $version"
            
            # Check if source file exists
            if [[ ! -f "$file" ]]; then
              echo "‚ùå Source file not found: $file"
              action="Failed - Source Not Found"
              ((failed_count++))
            else
              # Convert to PNG with better error handling
              echo "üé® Running draw.io conversion..."
              
              # Run draw.io conversion and capture output
              conversion_output=""
              if conversion_output=$(xvfb-run --auto-servernum --server-args="-screen 0 1024x768x24" drawio -x -f png -s 2.0 -o "$png_file" "$file" 2>&1); then
                conversion_success="true"
              else
                conversion_success="false"
              fi
              
              echo "üîç Draw.io output: $conversion_output"
              echo "üîç Conversion success: $conversion_success"
              
              # Check if conversion was successful by verifying the output file
              if [[ -f "$png_file" && -s "$png_file" ]]; then
                file_size=$(stat -c%s "$png_file" 2>/dev/null || stat -f%z "$png_file" 2>/dev/null || echo "unknown")
                echo "‚úÖ Successfully converted $basename (${file_size} bytes)"
                action="Converted to PNG"
                ((processed_count++))
              else
                echo "‚ùå PNG conversion failed for: $basename"
                echo "üîç Debug: PNG file exists: $(test -f "$png_file" && echo "yes" || echo "no")"
                echo "üîç Debug: PNG file size: $(test -s "$png_file" && echo "non-zero" || echo "zero/missing")"
                action="Failed - Conversion Error"
                ((failed_count++))
              fi
            fi
            
          # Add to changelog with proper version
          changelog_entry="${current_date},${current_time},\"${basename}\",\"${action}\",\"${version}\",\"${commit_hash}\",\"${author_name}\",\"${commit_message}\""
          echo "üîç Debug: Adding changelog entry: $changelog_entry"
          echo "$changelog_entry" >> png_files/CHANGELOG.csv
          
          # Verify the entry was added
          if tail -n 1 png_files/CHANGELOG.csv | grep -q "$basename"; then
            echo "‚úÖ Changelog entry added successfully"
          else
            echo "‚ùå Failed to add changelog entry"
            echo "üîç Debug: Last line of changelog: $(tail -n 1 png_files/CHANGELOG.csv)"
          fi
            
            done <<< "$changed_files"
          fi
          
          echo "üìä Conversion Summary:"
          echo "‚úÖ Successfully processed: $processed_count files"
          echo "‚ùå Failed: $failed_count files"
          
          echo "processed=$processed_count" >> $GITHUB_OUTPUT
          echo "failed=$failed_count" >> $GITHUB_OUTPUT
          
          # List generated files
          echo "üìÅ Generated PNG files:"
          ls -la png_files/*.png 2>/dev/null || echo "No PNG files found"
          
          echo "üìÑ Changelog contents:"
          tail -5 png_files/CHANGELOG.csv 2>/dev/null || echo "No changelog entries found"
          
          echo "üîç Debug: Final checks before exit..."
          echo "üîç Debug: processed_count=$processed_count"
          echo "üîç Debug: failed_count=$failed_count"
          echo "üîç Debug: PNG files exist: $(ls png_files/*.png 2>/dev/null | wc -l || echo 0)"
          echo "üîç Debug: Changelog exists: $(test -f png_files/CHANGELOG.csv && echo "yes" || echo "no")"
          
          # Ensure the script exits successfully
          echo "üîç Debug: Exiting with success..."
          exit 0

      - name: Commit Changes
        if: always()  # Always run this step to ensure files are committed
        run: |
          echo "üîç Debug: Preparing to commit changes..."
          echo "üîç Debug: Processed count: ${{ steps.convert.outputs.processed }}"
          
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          echo "üîç Debug: Current git status before adding:"
          git status
          
          echo "üîç Debug: Contents of png_files directory:"
          ls -la png_files/ || echo "png_files directory doesn't exist"
          
          echo "üîç Debug: Adding png_files to git..."
          git add png_files/
          
          echo "üîç Debug: Git status after adding:"
          git status
          
          echo "üîç Debug: Checking if there are staged changes..."
          if git diff --staged --quiet; then
            echo "‚ö†Ô∏è No staged changes detected"
            echo "üîç Debug: Checking if png_files directory has any files to commit..."
            
            # Check if png_files directory exists and has files
            if [[ -d "png_files" ]] && [[ -n "$(ls -A png_files/)" ]]; then
              echo "üìÅ png_files directory has content but no staged changes detected"
              echo "üîç Debug: Force adding png_files directory..."
              git add png_files/ --force
              
              echo "üîç Debug: Checking staged changes after force add..."
              if git diff --staged --quiet; then
                echo "‚ö†Ô∏è Still no staged changes after force add"
                echo "üîç Debug: Files in png_files:"
                ls -la png_files/
                echo "üîç Debug: Git status:"
                git status --porcelain
              else
                echo "‚úÖ Force add successful, committing..."
                echo "üîç Debug: Files to be committed:"
                git diff --staged --name-only
                
                git commit -m "Create PNG files directory and changelog [skip ci]"
                echo "‚úÖ Committed successfully"
                
                echo "üîç Debug: Pushing to remote..."
                git push
                echo "‚úÖ Pushed successfully"
              fi
            else
              echo "‚ö†Ô∏è No png_files directory or content to commit"
              echo "üîç Debug: Directory exists: $(test -d png_files && echo "yes" || echo "no")"
              echo "üîç Debug: Directory content: $(ls png_files/ 2>/dev/null || echo "empty/missing")"
            fi
          else
            echo "‚úÖ Changes detected, committing..."
            echo "üîç Debug: Files to be committed:"
            git diff --staged --name-only
            
            git commit -m "Generate PNG files and update changelog [skip ci]"
            echo "‚úÖ Committed successfully"
            
            echo "üîç Debug: Pushing to remote..."
            git push
            echo "‚úÖ Pushed successfully"
          fi

      - name: Upload to SharePoint
        id: sharepoint_upload
        if: always()
        continue-on-error: true
        run: |
          echo "üîç Debug: SharePoint upload step starting..."
          echo "üîç Debug: Convert step result: ${{ steps.convert.result }}"
          echo "üîç Debug: Convert step conclusion: ${{ steps.convert.conclusion }}"
          echo "üîç Debug: Convert step outcome: ${{ steps.convert.outcome }}"
          echo "üîç Debug: Processed count: ${{ steps.convert.outputs.processed }}"
          
          # Get access token
          ACCESS_TOKEN=$(curl -s -X POST \
            "https://login.microsoftonline.com/${{ vars.DIAGRAMS_SHAREPOINT_TENANT_ID }}/oauth2/v2.0/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "client_id=${{ vars.DIAGRAMS_SHAREPOINT_CLIENT_ID }}" \
            -d "client_secret=${{ secrets.DIAGRAMS_SHAREPOINT_CLIENTSECRET }}" \
            -d "scope=https://graph.microsoft.com/.default" \
            -d "grant_type=client_credentials" | \
            jq -r '.access_token')
          
          if [[ "$ACCESS_TOKEN" != "null" && -n "$ACCESS_TOKEN" ]]; then
            # Upload changelog to SharePoint using the configured URL variable
            sharepoint_url="${{ vars.DIAGRAMS_SHAREPOINT_URL }}"
            echo "üîç Debug: Uploading changelog to SharePoint..."
            echo "üîç Debug: SharePoint URL from variable: '$sharepoint_url'"
            echo "üîç Debug: Target path: Diagrams/Diagrams_Changelog.csv"
            
            # Extract site path from the SharePoint URL for Graph API
            # URL format: https://frostaag.sharepoint.com/sites/DatasphereFileConnector
            if [[ "$sharepoint_url" =~ https://([^/]+)/sites/([^/]+) ]]; then
              tenant_domain="${BASH_REMATCH[1]}"
              site_name="${BASH_REMATCH[2]}"
              drive_id="${{ vars.DIAGRAMS_SHAREPOINT_DRIVE_ID }}"
              
              echo "üîç Debug: Extracted tenant: '$tenant_domain', site: '$site_name'"
              echo "üîç Debug: Configured Drive ID: '$drive_id'"
              
              # If no drive ID configured, auto-discover the default one
              if [[ -z "$drive_id" ]]; then
                echo "üîç Debug: No Drive ID configured, auto-discovering default drive..."
                graph_site_url="${tenant_domain}:/sites/${site_name}:"
                
                # Get the default drive ID from the site
                drives_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X GET \
                  "https://graph.microsoft.com/v1.0/sites/${graph_site_url}/drives" \
                  -H "Authorization: Bearer $ACCESS_TOKEN")
                
                drives_http_code=$(echo "$drives_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                drives_response_body=$(echo "$drives_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                
                echo "üîç Debug: Drives query HTTP Status: $drives_http_code"
                
                if [[ "$drives_http_code" -eq 200 ]]; then
                  # Extract the first drive ID (usually the default document library)
                  drive_id=$(echo "$drives_response_body" | jq -r '.value[0].id' 2>/dev/null || echo "")
                  echo "üîç Debug: Auto-discovered Drive ID: '$drive_id'"
                  
                  if [[ -z "$drive_id" || "$drive_id" == "null" ]]; then
                    echo "‚ùå Could not auto-discover drive ID"
                    echo "üîç Debug: Drives response: $drives_response_body"
                    echo "‚ÑπÔ∏è Please manually set DIAGRAMS_SHAREPOINT_DRIVE_ID variable"
                    exit 1
                  fi
                else
                  echo "‚ùå Failed to query drives (HTTP $drives_http_code)"
                  echo "üîç Debug: Response: $drives_response_body"
                  echo "‚ÑπÔ∏è Please manually set DIAGRAMS_SHAREPOINT_DRIVE_ID variable"
                  exit 1
                fi
              fi
              
              echo "üîç Debug: Using Drive ID: '$drive_id'"
              echo "üîç Debug: Drive ID length: ${#drive_id}"
              
              # Method 1: Ensure Diagrams folder exists and upload there
              echo "üîç Debug: Method 1 - Ensuring Diagrams folder exists..."
              graph_site_url="${tenant_domain}:/sites/${site_name}:"
              
              # First, check if Diagrams folder exists
              folder_check=$(curl -s -w "HTTPSTATUS:%{http_code}" -X GET \
                "https://graph.microsoft.com/v1.0/sites/${graph_site_url}/drives/${drive_id}/root:/Diagrams" \
                -H "Authorization: Bearer $ACCESS_TOKEN")
              
              folder_check_code=$(echo "$folder_check" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
              echo "üîç Debug: Folder check HTTP Status: $folder_check_code"
              
              if [[ "$folder_check_code" -ne 200 ]]; then
                echo "üîç Debug: Creating Diagrams folder..."
                create_folder=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST \
                  "https://graph.microsoft.com/v1.0/sites/${graph_site_url}/drives/${drive_id}/root/children" \
                  -H "Authorization: Bearer $ACCESS_TOKEN" \
                  -H "Content-Type: application/json" \
                  -d '{"name": "Diagrams", "folder": {}}')
                
                create_folder_code=$(echo "$create_folder" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                create_folder_body=$(echo "$create_folder" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                echo "üîç Debug: Create folder HTTP Status: $create_folder_code"
                echo "üîç Debug: Create folder Response: $create_folder_body"
                
                if [[ "$create_folder_code" -ne 200 && "$create_folder_code" -ne 201 ]]; then
                  echo "‚ùå Failed to create Diagrams folder"
                fi
              else
                echo "üîç Debug: Diagrams folder already exists"
              fi
              
              # Now try uploading to Diagrams folder (primary method)
              echo "üîç Debug: Uploading to Diagrams folder..."
              diagrams_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X PUT \
                "https://graph.microsoft.com/v1.0/sites/${graph_site_url}/drives/${drive_id}/root:/Diagrams/Diagrams_Changelog.csv:/content" \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                -H "Content-Type: text/csv" \
                --data-binary @png_files/CHANGELOG.csv)
              
              diagrams_http_code=$(echo "$diagrams_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
              diagrams_response_body=$(echo "$diagrams_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
              
              echo "üîç Debug: Diagrams folder upload HTTP Status: $diagrams_http_code"
              echo "üîç Debug: Diagrams folder upload Response: $diagrams_response_body"
              
              if [[ "$diagrams_http_code" -eq 200 || "$diagrams_http_code" -eq 201 ]]; then
                echo "‚úÖ Uploaded changelog to SharePoint Diagrams folder"
              else
                echo "‚ùå Failed upload to Diagrams folder (HTTP $diagrams_http_code)"
                
                # Method 2: Try direct drive access to Diagrams folder
                echo "üîç Debug: Method 2 - Trying direct drive access to Diagrams folder..."
                direct_diagrams_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X PUT \
                  "https://graph.microsoft.com/v1.0/drives/${drive_id}/root:/Diagrams/Diagrams_Changelog.csv:/content" \
                  -H "Authorization: Bearer $ACCESS_TOKEN" \
                  -H "Content-Type: text/csv" \
                  --data-binary @png_files/CHANGELOG.csv)
                
                direct_diagrams_http_code=$(echo "$direct_diagrams_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                direct_diagrams_response_body=$(echo "$direct_diagrams_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                
                echo "üîç Debug: Direct Diagrams HTTP Status: $direct_diagrams_http_code"
                echo "üîç Debug: Direct Diagrams Response: $direct_diagrams_response_body"
                
                if [[ "$direct_diagrams_http_code" -eq 200 || "$direct_diagrams_http_code" -eq 201 ]]; then
                  echo "‚úÖ Uploaded changelog to SharePoint Diagrams folder (direct access)"
                else
                  echo "‚ùå Failed direct upload to Diagrams folder (HTTP $direct_diagrams_http_code)"
                  
                  # Method 3: Last resort - upload to root with clear naming
                  echo "üîç Debug: Method 3 - Last resort upload to root..."
                  root_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X PUT \
                    "https://graph.microsoft.com/v1.0/drives/${drive_id}/root:/Diagrams_Changelog.csv:/content" \
                    -H "Authorization: Bearer $ACCESS_TOKEN" \
                    -H "Content-Type: text/csv" \
                    --data-binary @png_files/CHANGELOG.csv)
                  
                  root_http_code=$(echo "$root_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                  root_response_body=$(echo "$root_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                  
                  echo "üîç Debug: Root upload HTTP Status: $root_http_code"
                  echo "üîç Debug: Root upload Response: $root_response_body"
                  
                  if [[ "$root_http_code" -eq 200 || "$root_http_code" -eq 201 ]]; then
                    echo "‚ö†Ô∏è Uploaded changelog to SharePoint root (fallback - please move to Diagrams folder)"
                  else
                    echo "‚ùå All SharePoint upload methods failed"
                    echo "üîç Debug: Please verify permissions and configuration"
                  fi
                fi
              fi
            else
              echo "‚ùå Could not parse SharePoint URL: '$sharepoint_url'"
              echo "‚ùå Expected format: https://tenant.sharepoint.com/sites/sitename"
            fi
          else
            echo "‚ùå Failed to get SharePoint access token"
            echo "üîç Debug: ACCESS_TOKEN length: ${#ACCESS_TOKEN}"
            echo "üîç Debug: ACCESS_TOKEN starts with: $(echo "$ACCESS_TOKEN" | head -c 20)..."
          fi

      - name: Upload PNG files to SAP BTP Document Management
        id: sap_upload
        if: always()
        continue-on-error: true
        run: |
          echo "üîç Debug: SAP BTP upload step starting..."
          echo "üîç Debug: Convert step result: ${{ steps.convert.result }}"
          echo "üîç Debug: Convert step conclusion: ${{ steps.convert.conclusion }}"
          echo "üîç Debug: Convert step outcome: ${{ steps.convert.outcome }}"
          echo "üîç Debug: Processed count: ${{ steps.convert.outputs.processed }}"
          
          echo "üîç Starting SAP BTP Document Management upload..."
          
          # Check if SAP BTP variables are configured
          sap_token_url="${{ vars.DIAGRAMS_SAP_BTP_TOKEN_URL }}"
          sap_client_id="${{ vars.DIAGRAMS_SAP_BTP_CLIENT_ID }}"
          sap_dm_base_url="${{ vars.DIAGRAMS_SAP_BTP_DM_BASE_URL }}"
          sap_repository_id="${{ vars.DIAGRAMS_SAP_BTP_REPOSITORY_ID }}"
          
          echo "üîç Debug: SAP BTP Token URL configured: $(if [[ -n "$sap_token_url" ]]; then echo "Yes"; else echo "No"; fi)"
          echo "üîç Debug: SAP BTP Client ID configured: $(if [[ -n "$sap_client_id" ]]; then echo "Yes"; else echo "No"; fi)"
          echo "üîç Debug: SAP BTP DM Base URL configured: $(if [[ -n "$sap_dm_base_url" ]]; then echo "Yes"; else echo "No"; fi)"
          echo "üîç Debug: SAP BTP Repository ID configured: $(if [[ -n "$sap_repository_id" ]]; then echo "Yes"; else echo "No"; fi)"
          
          if [[ -n "$sap_token_url" && -n "$sap_client_id" && -n "$sap_dm_base_url" ]]; then
            echo "üì§ Getting SAP BTP access token..."
            echo "üîç Debug: Token URL: $(echo "$sap_token_url" | sed 's/\(.*\)\/oauth\/token.*/\1\/oauth\/token/')"
            echo "üîç Debug: Client ID: $(echo "$sap_client_id" | head -c 10)..."
            
            # Check client secret safely
            sap_client_secret="${{ secrets.DIAGRAMS_SAP_BTP_CLIENT_SECRET }}"
            if [[ -n "$sap_client_secret" ]]; then
              echo "üîç Debug: Client Secret configured: Yes (${#sap_client_secret} chars)"
            else
              echo "üîç Debug: Client Secret configured: No"
            fi
            
            echo "üîç Debug: DM Base URL: $sap_dm_base_url"
            
            # Get access token for SAP BTP Document Management
            echo "üîç Debug: About to make OAuth request..."
            echo "üîç Debug: Client ID first 20 chars: $(echo "$sap_client_id" | head -c 20)..."
            echo "üîç Debug: Client ID last 10 chars: ...$(echo "$sap_client_id" | tail -c 10)"
            echo "üîç Debug: Client Secret first 5 chars: $(echo "$sap_client_secret" | head -c 5)..."
            echo "üîç Debug: Client Secret last 5 chars: ...$(echo "$sap_client_secret" | tail -c 5)"
            
            # Enhanced curl request with proper URL encoding
            echo "üîç Debug: Testing different authentication methods..."
            
            # Method 1: Using form data with proper URL encoding
            sap_token_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST "$sap_token_url" \
              -H "Content-Type: application/x-www-form-urlencoded" \
              -H "Accept: application/json" \
              --data-urlencode "grant_type=client_credentials" \
              --data-urlencode "client_id=$sap_client_id" \
              --data-urlencode "client_secret=$sap_client_secret" \
              --max-time 30 \
              2>/dev/null || echo "CURL_FAILED")
            
            echo "üîç Debug: Method 1 (URL encoded) result:"
            sap_token_http_code=$(echo "$sap_token_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
            sap_token_response_body=$(echo "$sap_token_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
            echo "üîç Debug: HTTP Status: $sap_token_http_code"
            
            # If Method 1 fails, try Method 2: Basic Auth
            if [[ "$sap_token_http_code" -ne 200 ]]; then
              echo "üîç Debug: Method 1 failed, trying Basic Auth..."
              
              # Create base64 encoded credentials for Basic Auth
              basic_auth=$(echo -n "${sap_client_id}:${sap_client_secret}" | base64 -w 0)
              
              sap_token_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST "$sap_token_url" \
                -H "Content-Type: application/x-www-form-urlencoded" \
                -H "Accept: application/json" \
                -H "Authorization: Basic $basic_auth" \
                -d "grant_type=client_credentials" \
                --max-time 30 \
                2>/dev/null || echo "CURL_FAILED")
              
              echo "üîç Debug: Method 2 (Basic Auth) result:"
              sap_token_http_code=$(echo "$sap_token_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
              sap_token_response_body=$(echo "$sap_token_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
              echo "üîç Debug: HTTP Status: $sap_token_http_code"
            fi
            
            # If Method 2 fails, try Method 3: Manual form encoding
            if [[ "$sap_token_http_code" -ne 200 ]]; then
              echo "üîç Debug: Method 2 failed, trying manual form encoding..."
              
              # Manually URL encode special characters
              encoded_client_id=$(echo -n "$sap_client_id" | sed 's/!/%21/g' | sed 's/|/%7C/g')
              encoded_client_secret=$(echo -n "$sap_client_secret" | sed 's/=/%3D/g' | sed 's/+/%2B/g' | sed 's!/!%2F!g')
              
              echo "üîç Debug: Original Client ID: ${sap_client_id:0:30}..."
              echo "üîç Debug: Encoded Client ID: ${encoded_client_id:0:30}..."
              
              sap_token_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST "$sap_token_url" \
                -H "Content-Type: application/x-www-form-urlencoded" \
                -H "Accept: application/json" \
                -d "grant_type=client_credentials&client_id=${encoded_client_id}&client_secret=${encoded_client_secret}" \
                --max-time 30 \
                2>/dev/null || echo "CURL_FAILED")
              
              echo "üîç Debug: Method 3 (Manual encoding) result:"
              sap_token_http_code=$(echo "$sap_token_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
              sap_token_response_body=$(echo "$sap_token_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
              echo "üîç Debug: HTTP Status: $sap_token_http_code"
            fi
            
            echo "üîç Debug: Final SAP BTP token HTTP Status: $sap_token_http_code"
            echo "üîç Debug: Response body (truncated): $(echo "$sap_token_response_body" | head -c 200)..."
            
            sap_token_http_code=$(echo "$sap_token_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
            sap_token_response_body=$(echo "$sap_token_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
            
            echo "üîç Debug: SAP BTP token HTTP Status: $sap_token_http_code"
            echo "üîç Debug: Full curl response (sanitized): $sap_token_response_body"
            
            if [[ "$sap_token_http_code" -eq 200 ]]; then
              sap_access_token=$(echo "$sap_token_response_body" | jq -r '.access_token' 2>/dev/null || echo "")
              
              if [[ -n "$sap_access_token" && "$sap_access_token" != "null" ]]; then
                echo "‚úÖ SAP BTP access token obtained successfully"
                echo "üîç Debug: Token length: ${#sap_access_token}"
                
                # Ensure Diagrams folder exists in SAP DM (check and create on every run)
                diagrams_folder_id=""
                
                echo "üìÅ Ensuring Diagrams folder exists in SAP Document Management..."
                
                # Use repository ID if configured, otherwise default to root
                if [[ -n "$sap_repository_id" ]]; then
                  echo "üîç Debug: Using configured repository ID: $sap_repository_id"
                  sap_root_path="/browser/${sap_repository_id}/root"
                else
                  echo "üîç Debug: No repository ID configured, using default root"
                  sap_root_path="/browser/objects/root"
                fi
                
                # Always check for existing Diagrams folder first
                echo "üîç Debug: Searching for existing Diagrams folder..."
                echo "üîç Debug: API URL: ${sap_dm_base_url}${sap_root_path}/children"
                folders_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X GET \
                  "${sap_dm_base_url}${sap_root_path}/children?filter=objectType%20eq%20'folder'%20and%20name%20eq%20'Diagrams'" \
                  -H "Authorization: Bearer $sap_access_token" \
                  -H "Accept: application/json")
                
                folders_http_code=$(echo "$folders_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                folders_response_body=$(echo "$folders_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                
                echo "üîç Debug: Folders search HTTP Status: $folders_http_code"
                
                if [[ "$folders_http_code" -eq 200 ]]; then
                  # Check if Diagrams folder exists
                  folder_count=$(echo "$folders_response_body" | jq -r '.objects | length' 2>/dev/null || echo "0")
                  
                  if [[ "$folder_count" -gt 0 ]]; then
                    diagrams_folder_id=$(echo "$folders_response_body" | jq -r '.objects[0].id' 2>/dev/null || echo "")
                    echo "‚úÖ Found existing Diagrams folder: $diagrams_folder_id"
                  fi
                fi
                
                # If folder doesn't exist or couldn't be found, create it
                if [[ -z "$diagrams_folder_id" || "$diagrams_folder_id" == "null" ]]; then
                  echo "üìÅ Creating Diagrams folder in SAP Document Management..."
                  echo "üîç Debug: Create folder URL: ${sap_dm_base_url}${sap_root_path}/children"
                  
                  create_folder_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST \
                    "${sap_dm_base_url}${sap_root_path}/children" \
                    -H "Authorization: Bearer $sap_access_token" \
                    -H "Content-Type: application/json" \
                    -H "Accept: application/json" \
                    -d '{
                      "name": "Diagrams",
                      "description": "Automatically generated diagram files from GitHub workflow",
                      "objectType": "folder"
                    }')
                  
                  create_folder_http_code=$(echo "$create_folder_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                  create_folder_response_body=$(echo "$create_folder_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                  
                  echo "üîç Debug: Create folder HTTP Status: $create_folder_http_code"
                  
                  if [[ "$create_folder_http_code" -eq 201 ]]; then
                    diagrams_folder_id=$(echo "$create_folder_response_body" | jq -r '.id' 2>/dev/null || echo "")
                    echo "‚úÖ Successfully created Diagrams folder: $diagrams_folder_id"
                  elif [[ "$create_folder_http_code" -eq 409 ]]; then
                    # Folder already exists (conflict), try to find it again
                    echo "üìÅ Diagrams folder already exists (HTTP 409), searching again..."
                    retry_folders_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X GET \
                      "${sap_dm_base_url}${sap_root_path}/children?filter=objectType%20eq%20'folder'%20and%20name%20eq%20'Diagrams'" \
                      -H "Authorization: Bearer $sap_access_token" \
                      -H "Accept: application/json")
                    
                    retry_folders_http_code=$(echo "$retry_folders_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                    retry_folders_response_body=$(echo "$retry_folders_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                    
                    if [[ "$retry_folders_http_code" -eq 200 ]]; then
                      retry_folder_count=$(echo "$retry_folders_response_body" | jq -r '.objects | length' 2>/dev/null || echo "0")
                      if [[ "$retry_folder_count" -gt 0 ]]; then
                        diagrams_folder_id=$(echo "$retry_folders_response_body" | jq -r '.objects[0].id' 2>/dev/null || echo "")
                        echo "‚úÖ Found Diagrams folder after conflict: $diagrams_folder_id"
                      fi
                    fi
                  else
                    echo "‚ùå Failed to create Diagrams folder (HTTP $create_folder_http_code)"
                    echo "üîç Debug: Response: $create_folder_response_body"
                  fi
                fi
                
                # Final fallback: use appropriate root path if we still don't have a folder ID
                if [[ -z "$diagrams_folder_id" || "$diagrams_folder_id" == "null" ]]; then
                  echo "‚ö†Ô∏è Could not create or find Diagrams folder, using root as fallback"
                  if [[ -n "$sap_repository_id" ]]; then
                    diagrams_folder_id="${sap_repository_id}/root"
                    echo "üîç Debug: Using repository root: $diagrams_folder_id"
                  else
                    diagrams_folder_id="root"
                    echo "üîç Debug: Using default root: $diagrams_folder_id"
                  fi
                else
                  echo "üìÅ Using Diagrams folder for uploads: $diagrams_folder_id"
                fi
                
                # Upload PNG files to SAP Document Management
                upload_count=0
                failed_upload_count=0
                
                for png_file in png_files/*.png; do
                  if [[ -f "$png_file" ]]; then
                    filename=$(basename "$png_file")
                    echo "üì§ Uploading $filename to SAP Document Management..."
                    
                    # Get file metadata for upload
                    file_size=$(stat -c%s "$png_file" 2>/dev/null || stat -f%z "$png_file" 2>/dev/null || echo "0")
                    
                    # First, create the document object
                    # Construct the correct URL based on whether we have a folder ID or are using root
                    if [[ "$diagrams_folder_id" == *"/root" ]]; then
                      # Using repository root
                      upload_url="${sap_dm_base_url}/browser/${diagrams_folder_id}/children"
                    else
                      # Using a specific folder ID
                      upload_url="${sap_dm_base_url}/browser/objects/${diagrams_folder_id}/children"
                    fi
                    
                    echo "üîç Debug: Upload URL: $upload_url"
                    
                    create_doc_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST \
                      "$upload_url" \
                      -H "Authorization: Bearer $sap_access_token" \
                      -H "Content-Type: application/json" \
                      -H "Accept: application/json" \
                      -d "{
                        \"name\": \"$filename\",
                        \"description\": \"Automatically generated diagram from GitHub workflow\",
                        \"objectType\": \"document\",
                        \"contentType\": \"image/png\"
                      }")
                    
                    create_doc_http_code=$(echo "$create_doc_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                    create_doc_response_body=$(echo "$create_doc_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                    
                    echo "üîç Debug: Create document HTTP Status: $create_doc_http_code"
                    
                    if [[ "$create_doc_http_code" -eq 201 ]]; then
                      document_id=$(echo "$create_doc_response_body" | jq -r '.id' 2>/dev/null || echo "")
                      
                      if [[ -n "$document_id" && "$document_id" != "null" ]]; then
                        echo "üìÑ Created document object: $document_id"
                        
                        # Upload the actual file content
                        upload_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X PUT \
                          "${sap_dm_base_url}/browser/objects/${document_id}/content" \
                          -H "Authorization: Bearer $sap_access_token" \
                          -H "Content-Type: image/png" \
                          --data-binary @"$png_file")
                        
                        upload_http_code=$(echo "$upload_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                        upload_response_body=$(echo "$upload_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
                        
                        echo "üîç Debug: File upload HTTP Status: $upload_http_code"
                        
                        if [[ "$upload_http_code" -eq 200 || "$upload_http_code" -eq 201 ]]; then
                          echo "‚úÖ Successfully uploaded $filename to SAP Document Management"
                          ((upload_count++))
                        else
                          echo "‚ùå Failed to upload file content for $filename (HTTP $upload_http_code)"
                          echo "üîç Debug: Upload response: $upload_response_body"
                          ((failed_upload_count++))
                        fi
                      else
                        echo "‚ùå Could not extract document ID from response"
                        ((failed_upload_count++))
                      fi
                    else
                      echo "‚ùå Failed to create document object for $filename (HTTP $create_doc_http_code)"
                      echo "üîç Debug: Create doc response: $create_doc_response_body"
                      ((failed_upload_count++))
                    fi
                  fi
                done
                
                echo "üìä SAP BTP Upload Summary:"
                echo "‚úÖ Successfully uploaded: $upload_count files"
                echo "‚ùå Failed uploads: $failed_upload_count files"
                
                # Set output for Teams notification
                if [[ $upload_count -gt 0 ]]; then
                  echo "sap_status=success" >> $GITHUB_OUTPUT
                  echo "sap_message=Uploaded $upload_count files to SAP BTP" >> $GITHUB_OUTPUT
                else
                  echo "sap_status=failed" >> $GITHUB_OUTPUT
                  echo "sap_message=Failed to upload files to SAP BTP" >> $GITHUB_OUTPUT
                fi
                
              else
                echo "‚ùå Could not extract access token from SAP BTP response"
                echo "üîç Debug: Token response: $sap_token_response_body"
                echo "sap_status=failed" >> $GITHUB_OUTPUT
                echo "sap_message=Could not extract access token" >> $GITHUB_OUTPUT
              fi
            else
              echo "‚ùå Failed to get SAP BTP access token (HTTP $sap_token_http_code)"
              echo "üîç Debug: Token response: $sap_token_response_body"
              
              # Provide specific troubleshooting advice based on error
              if [[ "$sap_token_http_code" -eq 401 ]]; then
                echo ""
                echo "üîß SAP BTP Authentication Troubleshooting (HTTP 401):"
                echo "   This indicates invalid credentials. Please verify:"
                echo "   1. Client ID is correct (starts with 'sb-' and ends with service instance GUID)"
                echo "   2. Client Secret is the correct value from service key"
                echo "   3. Token URL matches your subaccount's authentication domain"
                echo ""
                echo "üìã Current Configuration Check:"
                echo "   ‚Ä¢ Token URL: $sap_token_url"
                echo "   ‚Ä¢ Client ID format: $(echo "$sap_client_id" | grep -E '^sb-[a-f0-9-]+!\w+\|\w+!\w+$' && echo "‚úÖ Valid format" || echo "‚ùå Invalid format")"
                echo "   ‚Ä¢ Client ID length: ${#sap_client_id} chars (should be ~80-120)"
                echo "   ‚Ä¢ Client Secret length: ${#sap_client_secret} chars (should be ~40-50)"
                echo ""
                echo "üîç Expected formats:"
                echo "   ‚Ä¢ Client ID: sb-[uuid]![service]|[plan]![instance]"
                echo "   ‚Ä¢ Example: sb-a89eef4d-1cc2-4171-a69a-19fd2b4dbaa9!b523612|sdm-di-SDM_DI_PROD-prod!b41064"
                echo ""
                echo "üí° To get correct values:"
                echo "   1. Go to SAP BTP Cockpit ‚Üí Your Subaccount"
                echo "   2. Services ‚Üí Instances and Subscriptions"
                echo "   3. Find your Document Management instance"
                echo "   4. Create/View Service Key"
                echo "   5. Use 'clientid' and 'clientsecret' from the service key"
              elif [[ "$sap_token_http_code" -eq 400 ]]; then
                echo ""
                echo "üîß SAP BTP Request Format Error (HTTP 400):"
                echo "   Check that the OAuth request format is correct"
                echo "   Verify grant_type=client_credentials is supported"
              elif [[ "$sap_token_http_code" -eq 404 ]]; then
                echo ""
                echo "üîß SAP BTP Endpoint Not Found (HTTP 404):"
                echo "   Token URL appears to be incorrect"
                echo "   Expected format: https://[subdomain].authentication.[region].hana.ondemand.com/oauth/token"
              else
                echo ""
                echo "üîß SAP BTP Unexpected Error (HTTP $sap_token_http_code):"
                echo "   Check network connectivity and SAP BTP service status"
              fi
              
              echo "sap_status=failed" >> $GITHUB_OUTPUT
              echo "sap_message=Authentication failed (HTTP $sap_token_http_code)" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è SAP BTP Document Management not configured"
            echo "‚ÑπÔ∏è To enable SAP BTP uploads, set these organization variables:"
            echo "   - DIAGRAMS_SAP_BTP_TOKEN_URL (OAuth2 token endpoint)"
            echo "   - DIAGRAMS_SAP_BTP_CLIENT_ID (OAuth2 client ID)"
            echo "   - DIAGRAMS_SAP_BTP_DM_BASE_URL (Document Management API base URL)"
            echo "   - DIAGRAMS_SAP_BTP_REPOSITORY_ID (Optional: specific repository ID)"
            echo "   And this secret:"
            echo "   - DIAGRAMS_SAP_BTP_CLIENT_SECRET (OAuth2 client secret)"
            echo "sap_status=not_configured" >> $GITHUB_OUTPUT
            echo "sap_message=SAP BTP not configured" >> $GITHUB_OUTPUT
          fi

  notify:
    needs: process
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Checkout for Teams Notification
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
          
      - name: Send Teams Notification
        continue-on-error: true
        run: |
          echo "üîî Preparing Teams notification..."
          
          if [[ "${{ needs.process.result }}" == "success" ]]; then
            status="‚úÖ Success"
            color="28a745"
          else
            status="‚ùå Failed"
            color="dc3545"
          fi
          
          processed="${{ needs.process.outputs.processed || '0' }}"
          failed="${{ needs.process.outputs.failed || '0' }}"
          
          # Get git information
          commit_hash=$(git log -1 --format="%h" 2>/dev/null || echo "unknown")
          commit_full_hash=$(git log -1 --format="%H" 2>/dev/null || echo "unknown")
          commit_message=$(git log -1 --format="%s" 2>/dev/null || echo "Manual processing")
          
          # Get author with fallback: display name -> email -> github actor
          author_display_name=$(git log -1 --format="%an" 2>/dev/null || echo "")
          author_email=$(git log -1 --format="%ae" 2>/dev/null || echo "")
          
          # Use display name, fallback to email if display name is empty or generic
          if [[ -z "$author_display_name" || "$author_display_name" == "GitHub" || "$author_display_name" == "github-actions" ]]; then
            if [[ -n "$author_email" && "$author_email" != "noreply@github.com" ]]; then
              author_info="$author_email"
            else
              author_info="${{ github.actor }}"
            fi
          else
            author_info="$author_display_name"
          fi
          
          # Get processed diagram name (single diagram per commit)
          diagram_name=""
          diagram_display_name=""
          if [[ -f "png_files/CHANGELOG.csv" ]]; then
            # Get the most recent diagram from changelog
            diagram_name=$(tail -n 1 png_files/CHANGELOG.csv | cut -d',' -f3 | tr -d '"' 2>/dev/null || echo "")
          fi
          
          if [[ -z "$diagram_name" || "$diagram_name" == "Diagram" || "$diagram_name" == "System" ]]; then
            diagram_display_name="No specific diagram"
          else
            # Parse the diagram name to extract readable parts
            # Expected format: x.y.description (e.g., "1.2.Azure Cloud Architecture")
            if [[ "$diagram_name" =~ ^([0-9]+)\.([0-9]+)\.(.+)$ ]]; then
              tech_id="${BASH_REMATCH[1]}"
              detail_level="${BASH_REMATCH[2]}"
              description="${BASH_REMATCH[3]}"
              
              # Map technology IDs to readable names
              case "$tech_id" in
                0) tech_name="Multi-tech" ;;
                1) tech_name="Cloud" ;;
                2) tech_name="Network" ;;
                3) tech_name="SAP" ;;
                *) tech_name="Tech-$tech_id" ;;
              esac
              
              # Map detail levels to readable names
              case "$detail_level" in
                1) detail_name="High-level" ;;
                2) detail_name="Intermediate" ;;
                3) detail_name="Detailed" ;;
                *) detail_name="Level-$detail_level" ;;
              esac
              
              diagram_display_name="üìä $description ($tech_name, $detail_name)"
            else
              diagram_display_name="üìä $diagram_name"
            fi
          fi
          
          echo "üîç Debug: commit_hash=$commit_hash"
          echo "üîç Debug: author_display_name=$author_display_name"
          echo "üîç Debug: author_email=$author_email"
          echo "üîç Debug: author_info=$author_info"
          echo "üîç Debug: commit_message=$commit_message"
          echo "üîç Debug: diagram_name=$diagram_name"
          
          # Check if Teams webhook is configured using organization variable
          teams_webhook="${{ vars.DIAGRAMS_TEAMS_NOTIFICATION_WEBHOOK }}"
          
          echo "üîç Teams webhook configured: $(if [[ -n "$teams_webhook" ]]; then echo "Yes (${#teams_webhook} chars)"; else echo "No"; fi)"
          echo "üîç Using organization variable: DIAGRAMS_TEAMS_NOTIFICATION_WEBHOOK"
          echo "üîç Variable status: $(if [[ -n "${{ vars.DIAGRAMS_TEAMS_NOTIFICATION_WEBHOOK }}" ]]; then echo "Set"; else echo "Not set"; fi)"
          
          if [[ -n "$teams_webhook" ]]; then
            echo "üì§ Sending Teams notification..."
            echo "üîç Teams webhook URL starts with: $(echo "$teams_webhook" | head -c 50)..."
            
            # Create JSON payload with proper escaping
            echo "üîç Sending payload to Teams..."
            
            # Simplified title
            simple_title="üìä Draw.io Processing Complete"
            
            # Build summary text
            if [[ "$processed" != "0" && "$failed" == "0" ]]; then
              summary_text="Successfully processed $processed diagram(s)"
            elif [[ "$processed" != "0" && "$failed" != "0" ]]; then
              summary_text="Processed $processed, failed $failed diagram(s)"
            elif [[ "$processed" == "0" && "$failed" != "0" ]]; then
              summary_text="Failed to process $failed diagram(s)"
            else
              summary_text="No diagrams found to process"
            fi
            
            # Escape commit message and diagram name for JSON
            escaped_commit_message=$(echo "$commit_message" | sed 's/"/\\"/g' | sed "s/'/\\'/g")
            escaped_diagram_display_name=$(echo "$diagram_display_name" | sed 's/"/\\"/g')
            escaped_author_info=$(echo "$author_info" | sed 's/"/\\"/g')
            
            response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST "$teams_webhook" \
              -H "Content-Type: application/json" \
              -d "{
                \"@type\": \"MessageCard\",
                \"@context\": \"https://schema.org/extensions\",
                \"summary\": \"$simple_title\",
                \"themeColor\": \"$color\",
                \"title\": \"$simple_title\",
                \"text\": \"**Status:** $status - $summary_text\",
                \"sections\": [{
                  \"activityTitle\": \"üìã Processing Details\",
                  \"facts\": [
                    {\"name\": \"üë§ Author\", \"value\": \"$escaped_author_info\"},
                    {\"name\": \"üìù Commit\", \"value\": \"$commit_hash\"},
                    {\"name\": \"üí¨ Message\", \"value\": \"$escaped_commit_message\"},
                    {\"name\": \"üìä Diagram\", \"value\": \"$escaped_diagram_display_name\"},
                    {\"name\": \"‚úÖ Processed\", \"value\": \"$processed\"},
                    {\"name\": \"‚ùå Failed\", \"value\": \"$failed\"},
                    {\"name\": \"üîÑ Run\", \"value\": \"#${{ github.run_number }}\"}
                  ]
                }],
                \"potentialAction\": [{
                  \"@type\": \"OpenUri\",
                  \"name\": \"üîç View Details\",
                  \"targets\": [{
                    \"os\": \"default\",
                    \"uri\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
                  }]
                }, {
                  \"@type\": \"OpenUri\",
                  \"name\": \"üìÅ View Commit\",
                  \"targets\": [{
                    \"os\": \"default\",
                    \"uri\": \"${{ github.server_url }}/${{ github.repository }}/commit/$commit_full_hash\"
                  }]
                }]
              }")
            
            http_code=$(echo "$response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
            response_body=$(echo "$response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
            
            echo "üîç HTTP Status: $http_code"
            echo "üîç Response: $response_body"
            
            if [[ "$http_code" -eq 200 ]]; then
              echo "‚úÖ Teams notification sent successfully"
            elif [[ "$http_code" -eq 202 ]]; then
              echo "‚úÖ Teams notification accepted (HTTP 202)"
            else
              echo "‚ùå Failed to send Teams notification (HTTP $http_code)"
              echo "üîç Full response: $response"
              
              # Try simplified payload as fallback
              echo "üîç Trying simplified Teams payload..."
              simple_payload="{\"text\":\"üìä Draw.io Processing $status - $processed files processed, $failed failed (Run #${{ github.run_number }})\"}"
              
              simple_response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST "$teams_webhook" \
                -H "Content-Type: application/json" \
                -d "$simple_payload")
              
              simple_http_code=$(echo "$simple_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
              simple_response_body=$(echo "$simple_response" | sed -E 's/HTTPSTATUS:[0-9]*$//')
              
              echo "üîç Simple payload HTTP Status: $simple_http_code"
              echo "üîç Simple payload Response: $simple_response_body"
              
              if [[ "$simple_http_code" -eq 200 || "$simple_http_code" -eq 202 ]]; then
                echo "‚úÖ Teams notification sent successfully (simple format)"
              else
                echo "‚ùå Both Teams notification attempts failed"
              fi
            fi
          else
            echo "‚ö†Ô∏è Teams webhook not configured"
            echo "‚ÑπÔ∏è To enable Teams notifications:"
            echo "   Set organization variable: DIAGRAMS_TEAMS_NOTIFICATION_WEBHOOK"
            echo "   This should contain your Teams webhook URL (no authentication required)"
          fi
          
          echo "üìä Final Summary:"
          echo "- Status: $status"
          echo "- Files processed: $processed"
          echo "- Files failed: $failed"
          echo "- Workflow run: #${{ github.run_number }}"
